[Перелік усіх робіт](README.md)

# Робота з бінарним деревом пошуку

## Мета роботи 

Навчитися опрацьовувати бінарні дерева, вносити вносити та видаляти значення, проводити пошук у дереві. 

## Обладнання

Персональний комп’ютер, IDE Microsoft Visual Studio або інша середа розробки для мови C++

## Теоретичні відомості

Бінарне дерево — це ієрархічна структура даних, у якій кожен вузол має не більше двох дочірніх вузлів: лівий та правий. Бінарні дерева широко застосовуються для організації даних, що дозволяє ефективно виконувати пошук, вставку, видалення та сортування.

### Основні поняття та властивості

- **Корінь (Root):** Перший вузол дерева, з якого починається структура.
- **Вузол (Node):** Елемент дерева, який містить дані та посилання на дочірні вузли.
- **Лист (Leaf):** Вузол, який не має дочірніх вузлів.
- **Піддерево (Subtree):** Будь-яке дерево, що є частиною більшого дерева.
- **Висота дерева:** Довжина найдовшого шляху від кореня до листа.
- **Рівень вузла:** Відстань від кореня до вузла.

Бінарні дерева можуть бути різних видів: повні, повністю заповнені, вироджені (нагадують список), збалансовані та незбалансовані.

### Бінарне дерево пошуку (BST)

**Бінарне дерево пошуку (Binary Search Tree, BST)** — це бінарне дерево, яке задовольняє такі умови:
1. Для кожного вузла всі значення в лівому піддереві менші за значення вузла.
2. Всі значення в правому піддереві більші або рівні значенню вузла.
3. Кожне піддерево також є BST.

**Переваги BST:**
- Швидкий пошук, вставка та видалення (у середньому O(log n)).
- Динамічна структура, не потребує попереднього визначення розміру.

**Недоліки:**
- При невдалому порядку вставки дерево може виродитися у список (O(n) операції).
- Для підтримки ефективності потрібне балансування.

### Балансування бінарного дерева

**Збалансоване дерево** — це дерево, у якому різниця висот лівого і правого піддерева для будь-якого вузла не перевищує 1. Приклади: AVL-дерева, червоно-чорні дерева.

**Переваги збалансованих дерев:**
- Гарантовано швидкі операції (O(log n)).
- Уникають виродження у список.

**Незбалансовані дерева** можуть мати довгі гілки, що погіршує ефективність.

### Основні операції з BST

- **Вставка (Insert):** Додає новий елемент, дотримуючись властивостей BST.
- **Пошук (Search):** Порівнює ключ із вузлом, переходячи ліворуч або праворуч.
- **Видалення (Delete):** Може мати три випадки: вузол — лист, вузол має одного нащадка, вузол має двох нащадків (треба знайти мінімальний у правому піддереві або максимальний у лівому).
- **Обхід дерева:** 
  - **In-order (симетричний):** Ліве піддерево → вузол → праве піддерево (дає відсортований список).
  - **Pre-order (прямий):** Вузол → ліве піддерево → праве піддерево.
  - **Post-order (зворотний):** Ліве піддерево → праве піддерево → вузол.

### Пошук у BST

Пошук у BST виконується за принципом "ділення навпіл": на кожному кроці вибирається ліве або праве піддерево залежно від значення ключа. Це дозволяє досягати логарифмічної складності у збалансованих деревах.

### Застосування бінарних дерев

- Реалізація асоціативних масивів, множин, словників.
- Організація швидкого пошуку та сортування.
- Побудова виразів, парсери, індексація даних.

### Приклад вузла BST на C++

```cpp
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};
```

### Висновки

Бінарні дерева пошуку — одна з базових структур даних, що дозволяє ефективно організовувати та обробляти великі об'єми інформації. Для підтримки високої продуктивності важливо слідкувати за балансом дерева.

## Хід роботи

1. Завантажити Visual Studio. Знайдіть на робочому столі ярлик з Visual Studio або Пуск → Всі програми→ Microsoft → Microsoft Visual Studio.
2. Створити новий проект «Visual C++ (консольное приложение Win32)». Файл → Cтворити → Проект, тип проекту «Консольное приложение Win32».
3. Перевірити роботу програм, які вказані в прикладах до лабораторної роботи.
4. Оцініть складність реалізації бінарного дерева пошуку на мовах С та С++.
5. Додайте до програми на С++ наступні функції:
   1. Створіть клас Tree з вказівником на корінь дерева
   2. До класу Tree додайте метод друку дерева в консоль
   3. До класу Tree додайте методи додавання та видалення вузлів дерева
   4. Функцію пошуку зробіть членом класу Tree
   5. Змініть функцію пошуку таким чином, щоб вона підраховувала кількість порівнянь під час своєї роботи і записувала це значення у змінну класу Tree
   6. Модифікуйте основну програму таким чином, щоб дерево заповнювалось випадковими значеннями, а шукане значення вводилось з клавіатури
6.  Додайте програмний код завдання для самомтійного виконання
7.  Дайте відповіді на контрольні запитання
8.  Збережіть звіт у форматі PDF та надішліть викладачу

## Контрольні запитання

1. Чим бінарне дерево пошуку (BST) відрізняється від звичайного бінарного дерева?
3. Опишіть алгоритми вставки, пошуку та видалення елементів у BST. Які особливості має кожна з цих операцій?
4. Що таке балансування бінарного дерева? Які типи збалансованих дерев ви знаєте (наприклад, AVL, червоно-чорне дерево)?
5. Які наслідки може мати незбалансованість дерева для ефективності операцій?
6. Які існують основні види обходу бінарного дерева? Для чого використовується кожен з них?
7. Як знайти мінімальний і максимальний елемент у BST? Яка складність цієї операції?
8. Які практичні задачі ефективно вирішуються за допомогою бінарних дерев пошуку?
10. Які типові помилки виникають при реалізації операцій з BST і як їх уникати?
11. Як оцінити висоту дерева та чому це важливо для продуктивності?
12. Як організувати очищення пам’яті для всіх вузлів дерева у C++?
14. Які переваги та недоліки мають бінарні дерева порівняно з іншими структурами даних (масиви, списки, хеш-таблиці)?


## Приклади

1. [Просте бінарне дерево пошуку C++](src/lab-07/lab-07-001.cpp)
2. [Просте бінарне дерево пошуку C](src/lab-07/lab-07-002.c)


## Довідники та додаткові матеріали

