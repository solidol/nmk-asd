[Перелік усіх робіт](README.md)

# Створення бінарного дерева

## Мета роботи 

Навчитися працювати з розгалуженими динамічними структурами, реалізовувати за допомогою мови програмування високого рівня бінарне дерево пошуку. 

## Обладнання

Персональний комп’ютер, IDE Microsoft Visual Studio або інша середа розробки для мови C++

## Хід роботи

1. Завантажити Visual Studio. Знайдіть на робочому столі ярлик з Visual Studio або Пуск → Всі програми→ Microsoft → Microsoft Visual Studio.

2. Створити новий проект «Visual C++ (консольное приложение Win32)». Файл → Cтворити → Проект, тип проекту «Консольное приложение Win32».

3. Перевірити роботу програми та намалювати блок-схему алгоритму
```cpp
#include <iostream>
using namespace std;

// Структура ветки
struct Branch {
    int Data; // Поле даних
    Branch* LeftBranch; // Вказівники на ліву та праву гілку
    Branch* RightBranch;
};

// Функція внесення даних
void Add(char aData, Branch*& aBranch) {
    if (!aBranch) { // Якщо гілки не існує, створюємо її та додаємо дані
        aBranch = new Branch;
        aBranch->Data = aData;
        aBranch->LeftBranch = nullptr;
        aBranch->RightBranch = nullptr;
        return;
    } else { // В іншому випадку порівнюємо дані
        if (aData < aBranch->Data) {
            Add(aData, aBranch->LeftBranch);
        } else {
            Add(aData, aBranch->RightBranch);
        }
    }
}

// Функція виведення дерева
void Print(Branch* aBranch, int level = 0) {
    if (!aBranch) return; // Якщо гілки не існує, виходимо
    Print(aBranch->RightBranch, level + 1); // Виводимо праву гілку
    for (int i = 0; i < level; i++) cout << "  "; // Відступи для красивого відображення
    cout << aBranch->Data << endl; // Виводимо дані
    Print(aBranch->LeftBranch, level + 1); // Виводимо ліву гілку
}

// Функція для звільнення пам'яті, включаючи всі гілки
void FreeTree(Branch* aBranch) {
    if (!aBranch) return;
    FreeTree(aBranch->LeftBranch);
    FreeTree(aBranch->RightBranch);
    delete aBranch;
}

int main() {
    Branch* Root = nullptr;
    int s[] = {10, 6, 8, 14, 5, 2, 11, 13, 7, 15, 4, 3, 0, 16, 1, 17, 18, 12, 19};

    for (int i = 0; i < 20; i++) {
        Add(s[i], Root);
    }

    Print(Root);
    FreeTree(Root);

    cin.get();
    return 0;
}

```

4. Перевірте роботу прикладів за посиланнями нижче.
5. Виконайте самостійні завдання:
   1. Переосмисліть дану програму згідно із загальними правилами ООП
   2. Додайте до програми класс TreeNode який буде містити дані про вузли дерева
   3. Реалізуйте через методи класу функції додавання, видалення, пошуку
   4. Модифікуйте функцію пошуку так, щоб вона надавала інформацію про кількість переходів під час пошуку
   5. Додайте в програму можливість заповнення випадковими числами.
   6. Відповідно свого варіанту оберіть діапазон випадкових чисел: (номер_варіанта)\*100 - (номер_варіанта)\*100 + 200
6. Для кожного етапу роботи зробити знімки екрану та додати їх у звіт з описом кожного скіншота
7. Додати програмний код завдання для самомтійного виконання
8. Дати відповіді на контрольні запитання
9. Зберегти звіт у форматі PDF

## Контрольні запитання

1. Для чого потрібні структури в мові С++?
2. За допомогою якого ключового слова в програмі оголошується структура?
3. Який використувується оператор вибору для доступу до окремих членів структури?
4. Як ініціалізувати структуру?

## Приклади

1. [Бінарне дерево на структурах С++](src/lab-04/lab-04-001.cpp)
2. [Бінарне дерево на структурах С](src/lab-04/lab-04-002.c)
3. [Бінарне дерево на С++ з використанням ООП](src/lab-04/lab-04-003.cpp)

## Довідники та додаткові матеріали

1. [10.4: Бінарні дерева](https://ukrayinska.libretexts.org/%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0/%D0%9A%D0%BE%D0%BC%D0%B1%D1%96%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%B8%D0%BA%D0%B0_%D1%82%D0%B0_%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0/%D0%9F%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D1%96_%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D1%96_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8_(Doerr_%D1%96_Levasseur)/10%3A_%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%B0/10.04%3A_%D0%91%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D1%96_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0)
2. [Структура даних двійкового дерева в C ++](https://uk.myservername.com/binary-tree-data-structure-c)
3. [Бінарне дерево пошуку](https://sergiyshumakov.wordpress.com/2012/01/02/%D0%B1%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D0%B5-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE-%D0%BF%D0%BE%D1%88%D1%83%D0%BA%D1%83/)
4. [Створення БІнарного Дерева Пошуку](https://www.eolymp.com/uk/problems/3326)
5. [Бінарні дерева (коротко про головне)](https://purecodecpp.com/uk/archives/2483)
