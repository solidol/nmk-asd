[Перелік лекцій](README.md)

# Алгоритми сортування ч.2

## Швидке сортування (QuickSort)

QuickSort по праву называется королем среди алгоритмов сортировки, и наверное, самый известный алгоритм сортировки. Сам алгоритм был разработан в 1960году математиком Чарльзом Харном. В связи с тем, что в худшем случае, или в близком к худшему случае алгоритм невероятно деградирует, Роберт Седжвик, в своем курсе на Coursera рекомендует его перемешать перед проведенеием сортировки, и если после пересортировки ваш массив превратиться в самый худший случай — то вы действительно удивительно неудачливы, и вам стоит поставить свечку в церкве, чистить карму, да и всячески оправдываться перед судьбой, а не заниматься алгоритмами☺

Итак, сам алгоритм достаточно прост:

1. В начале выбирается “опорный” элемент массива. Это может быть любое число, но от выбора этого элемента сильно зависит эффективность алгоритма. Если нам известна медиана, то лучше выбирать элемент, который как можно ближе к медиане. В нашей реализации алгоритма, мы будем брать самый левый элемент, который в результате займет свое место.
2. Элементы в массиве делятся на две части: слева те кто меньше опорного элемента, справа те кто больше. Таким образом опорный элемент занимает свое место и больше никуда не двигается.
3. Для левого и правого массива действия повторяются рекурсивно.

## Сортування розподілом

Алгоритм порозрядного сортування вимагає представлення ключів сортованої послідовності у вигляді чисел в деякій системі числення _P_. Число проходів сортування рівно максимальному числу значущих цифр в числі - _D_. При кожному проході аналізується значуща цифра в черговому розряді ключа, починаючи з молодшого розряду. Всі ключі з однаковим значенням цієї цифри об’єднуються в одну групу. Ключі в групі розташовуються в порядку їхнього надходження. Після того, як вся початкова послідовність розподілена по групах, групи розташовуються в порядку зростання пов’язаних з групами цифр. Процес повторюється для другої цифри і т.д., поки не будуть вичерпані значущі цифри в ключі. Основа системи числення _P_ може бути будь-якою при цьому потрібно _P_ груп.

Порядок алгоритму якісно лінійний - _O(N)_, для сортування потрібно _D\*N_операцій аналізу цифри. Проте, в такій оцінці порядку не враховується ряд обставин.

По-перше, операція виділення значущої цифри буде простою і швидкою тільки при _P=2_, для інших систем числення ця операція може вимагати значно більше часу, ніж операція порівняння.

По-друге, при оцінці алгоритму не враховуються затрати часу і пам’яті на створення і ведення груп. Розміщення груп в статичній робочій пам’яті вимагає пам’яті для _P\*N_ елементів, оскільки в граничному випадку всі елементи можуть потрапити в якусь одну групу. Якщо ж формувати групи усередині тієї ж послідовності за принципом обмінних алгоритмів, то виникає необхідність перерозподілу послідовності між групами і всі проблеми і недоліки, властиві алгоритмам включення. Найбільш раціональним є формування груп у вигляді зв’язних списків з динамічним виділенням пам’яті.

Алгоритм швидкого сортування Хоара відноситься до розподільних і забезпечує показники ефективності _O(N\*log2(N))_ навіть при якнайгіршому початковому розподілі.

Використовується два індекси з початковими значеннями початку і кінця множини відповідно. Ключ початку порівнюється з ключем кінця. Якщо ключі задовольняють критерію впорядкованості, то індекс кінця зменшується на _1_ і проводиться наступне порівняння. Якщо ключі не задовольняють критерію, то записи міняються місцями. При цьому індекс кінця фіксується і починає мінятися індекс початку (збільшуватися на _1_ після кожного порівняння). Після наступної перестановки фіксується початок і починає змінюватися кінець і т.д. Прохід закінчується, коли індекси стають рівними. Запис, що знаходиться на позиції зустрічі індексів, стоїть на своєму місці в послідовності. Цей запис ділить послідовність на дві підмножини. Всі записи, розташовані ліворуч від неї мають ключі, менші ніж ключ цього запису, всі записи праворуч - більші. Той же самий алгоритм застосовується до лівої підмножини, а потім до правої. Записи підмножини розподіляються на дві менші підмножини і так далі. Розподіл закінчується, коли отримана підмножина буде складатися з єдиного елемента - така підмножина вже є впорядкованою.

## Сортування злиттям

Алгоритми сортування злиттям, як правило, мають порядок _O(N\*log2(N))_, але відрізняються від інших алгоритмів більшою складністю і вимагають великої кількості пересилок. Алгоритми злиття застосовуються в основному, як складова частина зовнішнього сортування.

При сортуванні попарним злиттям вхідна множина розглядається, як послідовність підмножин, кожна з яких складається з єдиного елемента і, отже, є вже впорядкованим. На першому проході кожні дві сусідні одноелементних множини зливаються в одну двоелементну впорядковану множину. На другому проході двоелементні множини зливаються в 4-елементні впорядковані множини і т.д. Врешті-решт отримують одну велику впорядковану множину.

Самою найважливішою частиною алгоритму є злиття двох впорядкованих множин. Цю частину алгоритму опишемо більш детально.

1. **Початкові установки**. Визначити довжини першої і другої початкових множин - _l1_ і _l2_ відповідно. Встановити індекси поточних елементів в початковій множині _і1_ і _і2_ в 0. Встановити індекс в вихідній множині _j=1_.

2. **Цикл злиття**. Виконувати крок 3 до тих пір, поки _і1<=11_ і _і2<=12_.

3. **Порівняння**. Порівняти ключ _і1_\-го елемента з першої початкової множини з ключем _і2_\-го елемента з другої початкової множини. Якщо ключ елемента з 1 -ої множини менший, то записати _і1_\-тий елемент з 1-ої множини на _j_\-те місце в вихідній множині і збільшити _і1_ на 1. Інакше - записати _і2_\-тий елемент з 2-ої множини на _j_\-те місце в вихідній множині і збільшити _і2_ на 1. Збільшити _j_ на 1.

4. **Виведення залишків**. Якщо _і1<=11_, то переписати частину 1-ої початкової множини від _і1_ до _l1_ включно в вихідну множину. Інакше - переписати частину 2-ої початкової множини від _і2_ до _l2_ включно в вихідну множину.

![](img/lec-14/14-020.gif)


## Сортування Шелла

Shell Sort один из самых загадочных алгоритмов. Являясь модификацией обычного Insertion Sort — все же нет точного доказательства его оптимальности в различных ситуациях. Вернее конфигурация алгоритма, которая однозначно бы говорила что больше из него не выжать — на даный момент однозначного ответеа нет.

Shell Sort — это тот же самый Insertion Sort, но перед сортировкой с помощью Insertion Sort, мы проводим “грубый” проход. Грубый проход — это сравнение элементов, которые находяться на расстоянии D. После этого сравниваются элементы которые находятся на меньшем расстоянии, и так, пока D=1, что является заключительной проверкой, после которой мы имеем отсортированный массив. Как помните из статьи об Insertion Sort сортировка проходит практически мгновенно, в случае если массив частично отсортирован.

Итак, в чем же неопределнность? Неопределенность, именно в этом самом выборе расстояния D между двумя числами.

Есть огромное количество методов выбора числа D:

1. Самый просто пример это D = n / 2, D2 = D /2 … Dn =1 . В худшем случае сложность алогритма O(n) = N ^ 2
2. Предложение Хиббарда: проверить на всем N^i — 1<= N. В таком случае сложность алгоритма O(n) = n ^ (3/2)
3. Числа Седжвика и много много другого

## Теми для самостійного вивчення

1.  Принципи роботи алгоритмів групи CRC
2.  Принципи роботи алгоритмів групи MD
3.  Принципи роботи алгоритмів групи SHA
4.  Недоліки алгоритмів групи MD

## Контрольні питання

1.  Як працює сортування Шелла, і що відрізняє його від інших алгоритмів сортування?
2.  Які переваги та недоліки сортування Шелла в порівнянні з іншими алгоритмами?
3.  Що таке сортування злиттям, і як відбувається процес злиття в цьому алгоритмі?
4.  Яким чином сортування злиттям впливає на швидкодію сортування, особливо при роботі з великими наборами даних?
5.  Як працює швидке сортування (Quicksort), і як обирається опорний елемент для розбиття масиву?
6.  Чому швидке сортування вважається ефективним для великих наборів даних?
7.  Які є найгірші та середні випадки для швидкого сортування?
8.  Як працює алгоритм сортування Шелла на практиці, і як вибирається розмір кроку для вставки?
9.  В яких випадках краще використовувати сортування Шелла, швидке сортування або сортування злиттям?