<!DOCTYPE html>
<html>
<head>
	<title> Лекція № 3</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<div class="paper">
		<div id="colontitle">АСД. Лекція № 3</div>
		<ul class="lec-menu"> 
			<li><a href="index.html">Зміст</a></li> 
			<li><a href="lec-01.html">01</a></li> 
			<li><a href="lec-02.html">02</a></li> 
			<li><a href="lec-03.html">03</a></li> 
			<li><a href="lec-04.html">04</a></li> 
			<li><a href="lec-05.html">05</a></li> 
			<li><a href="lec-06.html">06</a></li> 
			<li><a href="lec-07.html">07</a></li> 
			<li><a href="lec-08.html">08</a></li> 
			<li><a href="lec-09.html">09</a></li> 
			<li><a href="lec-10.html">10</a></li>  
		</ul> 
		<h1>Статичні структури. Структури та об'єднання</h1>
		<div class="content-board">
			<ol>

				<li><a href="#h01">Термінологія</a></li>

				<li><a href="#h101">Теми для самостійного вивчення</a></li>
				<li><a href="#h102">Контрольні питання</a></li>
			</ol>
		</div>

		<h2>Структури</h2>

		<p>
			На відміну від масивів чи множин, усі елементи яких однотипні, структура може містити елементи різних типів.
		</p>
		<figure>
			<img class="figc" src="img/03-010.png">
			<figcaption>Схематичне зображення масиву</figcaption>
		</figure>
		<figure>
			<img class="figc" src="img/03-011.png">
			<figcaption>Схематичне зображення структури (запису)</figcaption>
		</figure>


		<p>
			Елементи структури називаються полями структури і можуть мати довільний тип, крім типу цієї ж структури, але можуть бути покажчиками на неї. Якщо при описі структури відсутній тип структури, обов'язково повинен бути вказаний список змінних, покажчиків або масивів визначеної структури.
		</p>

		<p>
			Звернення до окремих полів структури замінюються на їхні адреси ще на етапі компіляції.
		</p>

		<p>
			Самою найважливішою операцією для структури є операція доступу до вибраного поля структури - операція кваліфікації.
		</p>

		<p>
			Над вибраним полем структури можливі будь-які операції, які допустимі для типів цього поля.
		</p>

		<p>
			Більшість мов програмування підтримує деякі операції, які працюють із структурою, як з єдиним цілим, а не з окремими її полями. Це операція присвоєння значення одного запису іншому однотипному запису, при цьому відбувається по елементне копіювання.
		</p>
		<h2>Об'єднання</h2>

		<p>
			Об'єднання представляють собою частковий випадок структури, усі поля якої розміщуються за однією ж і тою ж адресою. Формат опису такий же, як і в структури. Довжина об'єднання рівна найбільшій із довжин його полів. У кожен момент часу в змінній типу об'єднання зберігається тільки одне значення, і відповідальність за його правильне використання лягає на програміста.
		</p>

		<p>
			Об'єднання застосовуються для економії пам'яті в тих випадках, коли відомо, що більше одного поля одночасно не потрібно, а також для різної інтерпретації одного і того ж бітового представлення.
		</p>

		<p>
			Дуже часто деякі об'єкти програми відносяться до одного й того ж класу, відрізняючись лише деякими деталями. У цьому випадку застосовують комбінацію структурного типу і об'єднання. Об'єднання використовують як поля структури, при цьому в структурі включають поле, яке визначає, який саме елемент об'єднання використовується в кожний момент.
		</p>

		<p>
			У загальному випадку змінна структура буде складатися з трьох частин: набір спільних компонентів, мітки активного компоненту і частини зі змінними компонентами.
		</p>
		<h2>Таблиці</h2>

		<p>
			Елементами векторів і масивів можуть бути інтегровані структури. Одна з таких складних структур - таблиця. З фізичної точки зору таблиця є вектором, елементами якого є структури. Характерною логічною особливістю таблиць є те, що доступ до елементів таблиці проводиться не за номером (індексом), а за ключем - значення однієї з властивостей об'єкту, який описується структурою-елементом таблиці. Ключ - це властивість, що ідентифікує дану структуру в множині однотипних структур і є, як правило, унікальним в даній таблиці. Ключ може включатися до складу структури і бути одним з його полів, але може і не включатися в структуру, а обчислюватися за деякими її властивостями. Таблиця може мати один або декілька ключів.
		</p>

		<p>
			Основною операцією при роботі з таблицями є операція доступу до структури за ключем. Вона реалізовується процедурою пошуку. Оскільки пошук може бути значне більш ефективним в таблицях, впорядкованих за значеннями ключів, досить часто над таблицями необхідно виконувати операції сортування.
		</p>

		<p>
			Іноді розрізняють таблиці з фіксованою і із змінною довжиною структури. Очевидно, що таблиці, які об'єднують структури ідентичних типів, будуть мати фіксовані довжини структур. Необхідність в змінній довжині може виникнути в задачах, подібних до тих, які розглядалися для об'єднань. Як правило таблиці для таких задач і складаються із структур до складу яких входять об'єднання, тобто зводяться до фіксованої (максимальній) довжини структури. Значно рідше зустрічаються таблиці з дійсно змінною довжиною структури. Хоча в таких таблицях і економиться пам'ять, але можливості роботи з такими таблицями обмежені, оскільки за номером структури неможливо визначити її адресу. Таблиці із структурами змінної довжини обробляються тільки послідовно - в порядку зростання номерів структур. Доступ до елемента такої таблиці звичайно здійснюється в два кроки. На першому кроці вибирається постійна частина структури, в якій міститься, - в явному чи неявному вигляді - довжина структури. На другому кроці вибирається змінна частина структури у відповідності з її довжиною. Додавши до адреси поточної структури її довжину, одержують адресу наступної структури. 
		</p>
		<h2>Характерні особливості напівстатичних структур</h2>

		<p>
			Напівстатичні структури даних характеризуються наступними ознаками:
		</p>
		<ol>
			<li>вони мають змінну довжину і прості процедури її зміни;</li>
			<li>зміна довжини структури відбувається в певних межах, не перевищуючи якогось максимального (граничного) значення.</li>
		</ol>

		<p>
			Якщо напівстатичну структуру розглядати на логічному рівні, то це послідовність даних, зв'язана відносинами лінійного списку. Доступ до елемента може здійснюватися за його порядковим номером.
		</p>

		<p>
			Фізичне представлення напівстатичних структур даних в пам'яті - це звичайно послідовність комірок в пам'яті, де кожний наступний елемент розташований в пам'яті в наступній комірці. Фізичне представлення може мати також вид одно-направленого зв'язного списку (ланцюжки), де кожний наступний елемент адресується покажчиком, який знаходиться в поточному елементі. У цьому випадку обмеження на довжину структури менш строгі.
		</p>
		<h2>Стеки</h2>

		<p>
			Стеком називається множина деякої змінної кількості даних, над якою виконуються наступні операції:
		</p>
		<ol>
			<li>Поповнення стеку новими даними;</li>
			<li>Перевірка, яка визначає чи стек пустий;</li>
			<li>Перегляд останніх доданих даних;</li>
			<li>Знищення останніх доданих даних.</li>
		</ol>

		<p>
			На основі такого функціонального опису, можна сформувати логічний опис. Стек - це такий послідовний список із змінній довжиною, включення і виключення елементів з якого виконуються тільки з одного боку списку. Застосовуються і інші назви стеку - магазин, пам'ять що функціонує за принципом LIFO (Last-In-First-Out - „останнім прийшов - першим вийшов”).
		</p>

		<figure>
			<img class="figc" src="img/03-110.png">
			<figcaption>Схематичне зображення стеку</figcaption>
		</figure>

		<p>
			Самий„верхній” елемент стеку, тобто останній добавлений і ще не знищений, відіграє особливу роль: саме його можна модифікувати й знищувати. Цей елемент називають вершиною стеку. Іншу частину стеку називають тілом стеку. Тіло стеку, само собою, є стеком: якщо виключити зі стеку його вершину, то тіло перетворюється в стек.
		</p>

		<p>
			Основні операції над стеком - включення нового елемента (<b>push </b>- заштовхувати) і виключення елемента зі стеку (<b>pop </b>- вискакувати).
		</p>

		<p>
			Корисними можуть бути також допоміжні операції:
		</p>
		<ol>
			<li>визначення поточної кількості елементів в стеку;</li>
			<li>очищення стеку;</li>
			<li>„неруйнуюче” читання елемента з вершини стека, яке може бути реалізоване, як комбінація основних операцій -виключити елемент зі стеку та включити його знову в стек.</li>
		</ol>

		<p>
			При представленні стеку в статичній пам'яті для стеку виділяється пам'ять, як для вектора. В описі цього вектора окрім звичайних для вектора параметрів повинен знаходитися також покажчик стеку - адреса вершини стека. Обмеження даного представлення полягає в тому, що розмір стеку обмежений розмірами вектора.
		</p>

		<p>
			Покажчик стеку може вказувати або на перший вільний елемент стеку, або на останній записаний в стек елемент. Однаково, який з цих двох варіантів вибрати, важливо надалі строго дотримуватися його при обробці стеку.
		</p>

		<p>
			При занесенні елементу в стек елемент записується на місце, яке визначається покажчиком стеку, потім покажчик модифікується так, щоб він вказував на наступний вільний елемент (якщо покажчик вказує на останній записаний елемент,то спочатку модифікується покажчик, а потім проводиться запис елемента).Модифікація покажчика полягає в надбавці до нього або у відніманні від нього одиниці (стек росте у бік збільшення адреси).
		</p>

		<p>
			Операція виключення елемента полягає в модифікації покажчика стеку (в напрямку,зворотному модифікації при включенні) і вибірці значення, на яке вказує покажчик стеку. Після вибірки комірка, в якій розміщувався вибраний елемент,вважається вільною.
		</p>

		<p>
			Операція очищення стеку зводиться до запису в покажчик стеку початкового значення -адреси початку виділеної ділянки пам'яті.
		</p>

		<p>
			Визначення розміру стека зводиться до обчислення різниці покажчиків: покажчика стеку й адреси початку ділянки.
		</p>

		<p>
			При зв'язному представленні стеку кожен елемент стеку складається із значення і покажчика, який вказує на попередньо занесений у стек елемент. Зв'язне представлення викликає втрату пам'яті, що викликане наявністю покажчика в кожному елементі стеку, і представляє інтерес тільки у випадку, коли важко визначити максимальний розмір стеку.
		</p>

		<p>
			Отже,для зв'язного представлення стеку потрібно, щоб кожен його елемент описувався структурою, яка поєднує дані і покажчик на наступний елемент.
		</p>

		<p>
			Для виконання операцій над стеком потрібен один покажчик на вершину стеку.Створення пустого стеку полягатиме у присвоєнні покажчику на вершину нульового значення, що означатиме, що стек пустий.
		</p>

		<p>
			Послідовність кроків для додавання елементу в стек складається з декількох кроків:
		</p>
		<ol>
			<li>Виділити пам'ять під новий елемент стеку;</li>
			<li>Занесення значення в інформаційне поле;</li>
			<li>Встановлення зв'язку між ним і„старою” вершиною стеку;</li>
			<li>Переміщення вершини стеку на новий елемент.</li>
		</ol>

		<p>
			Вилученняелементу зі стеку також проводять за кілька кроків:
		</p>
		<ol>
			<li>Зчитування інформації з інформаційного поля вершини стеку;</li>
			<li>Встановлення на вершину стеку допоміжного покажчика;</li>
			<li>Переміщення покажчика вершини стеку на наступний елемент;</li>
			<li>Звільнення пам'яті, яку займає „стара” вершина стеку.</li>
		</ol>
		<h2>Черга</h2>

		<p>
			Чергою називається множина змінної кількості даних, над якою можна виконувати наступні операції:
		</p>
		<ol>
			<li>Поповнення черги новими даними;</li>
			<li>Перевірка, яка визначає чи пуста черга;</li>
			<li>Перегляд перших добавлених даних;</li>
			<li>Знищення самих перших доданих даних.</li>
		</ol>

		<p>
			На основі такого функціонального опису, можна сформувати логічний опис. ЧергоюFIFO (First - In - First - Out - „першим прийшов - першим вийшов”). Називається такий послідовний список із змінній довжиною, в якому включення елементів виконується тільки з одного боку списку (хвіст черги), а виключення - з другого боку (голова черги).
		</p>

		<figure>
			<img class="figc" src="img/03-120.png">
			<figcaption>Схематичне зображення черги</figcaption>
		</figure>

		<p>
			Основні операції над чергою - ті ж, що і над стеком - включення, виключення, визначення розміру, очищення, „неруйнуюче” читання.
		</p>

		<p>
			При представленні черги вектором в статичній пам'яті на додаток до звичайних для опису вектора параметрів в ньому повинні знаходитися два покажчики: на голову і на хвіст черги. При включенні елемента в чергу елемент записується за адресою,яка визначається покажчиком на хвіст, після чого цей покажчик збільшується на одиницю. При виключенні елемента з черги вибирається елемент, що адресується покажчиком на голову, після чого цей покажчик зменшується на одиницю.
		</p>

		<p>
			Очевидно,що з часом покажчик на хвіст при черговому включенні елемента досягне верхньої межі тієї ділянки пам'яті, яка виділена для черги. Проте, якщо операції включення чергувати з операціями виключення елементів, то в початковій частині відведеної під чергу пам'яті є вільне місце. Для того, щоб місця, займані виключеними елементами, могли бути повторно використані, черга замикається в кільце: покажчики (на початок і на кінець), досягнувши кінця виділеної області пам'яті, перемикаються на її початок. Така організація черги в пам'яті називається кільцевою чергою. Можливі, звичайно, і інші варіанти організації:наприклад, всякий раз, коли покажчик кінця досягне верхньої межі пам'яті, зсувати всі не порожні елементи черги до початку ділянки пам'яті, але як цей, так і інші варіанти вимагають переміщення в пам'яті елементів черги і менш ефективні,ніж кільцева черга.
		</p>

		<p>
			У початковому стані покажчики на голову і хвіст вказують на початок ділянки пам'яті. Рівність цих двох покажчиків є ознакою порожньої черги. Якщо в процесі роботи з кільцевою чергою кількість операцій включення перевищує кількість операцій виключення, то може виникнути ситуація, в якій покажчик кінця„наздожене” покажчик початку. Це ситуація заповненої черги, але якщо в цій ситуації покажчики порівняються, ця ситуація буде така ж як при порожній черзі.Для розрізнення цих двох ситуацій до кільцевої черги пред'являється вимога, щоб між покажчиком кінця і покажчиком початку залишався „проміжок” з вільних елементів. Коли цей „проміжок” скорочується до одного елемента, черга вважається заповненою і подальші спроби запису в неї блокуються. Очищення черги зводиться до запису одного і того ж (не обов'язково початкового) значення в обидва покажчики. Визначення розміру полягає в обчисленні різниці покажчиків з урахуванням кільцевої природи черги.
		</p>

		<p>
			При зв'язному представленні черги кожен елемент черги складається із значення іпокажчика, який вказує на попередньо занесений у чергу елемент.
		</p>

		<p>
			Зв'язне представлення викликає втрату пам'яті, що викликане наявністю покажчика в кожному елементі черги, і представляє інтерес тільки у випадку, коли важко визначити максимальний розмір черги. Для зв'язного представлення черги потрібно, щоб кожен його елемент описувався структурою, яка поєднує дані і покажчик на наступний елемент.
		</p>

		<p>
			Для виконання операцій над чергою потрібно два покажчики: на голову і хвіст черги.Створення пустої черги полягатиме у присвоєнні покажчикам на голову і хвістчерги нульових значень, що означатиме, що черга пуста.
		</p>

		<p>
			Послідовність кроків для додавання елемента в кінець черги складається з декількох кроків:
		</p>
		<ol>
			<li>Виділити пам'ять під новий елемент черги;</li>
			<li>Занесення значення в інформаційне поле;</li>
			<li>Занесення нульового значення в покажчик;</li>
			<li>Встановлення зв'язку між ним і останнім елементом черги і новим, враховуючи випадок пустої черги;</li>
			<li>Переміщення покажчика кінця черги на новий елемент.</li>
		</ol>

		<p>
			Вилучення елементу з черги також проводять за кілька кроків:
		</p>
		<ol>
			<li>Зчитування інформації з інформаційного поля голови черги;</li>
			<li>Встановлення на голову черги допоміжного покажчика;</li>
			<li>Переміщення покажчика початку черги на наступний елемент;</li>
			<li>Звільнення пам'яті, яку займав перший елемент черги.</li>
		</ol>

		<p>
			В реальних задачах іноді виникає необхідність у формуванні черг, відмінних від приведених структур. Порядок вибірки елементів з таких черг визначається пріоритетами елементів. Пріоритет в загальному випадку може бути представлений числовим значенням, яке обчислюється або на підставі значень яких-небудь полів елемента, або на підставі зовнішніх чинників. Так попередньо наведені структури стек і черги можна трактувати як пріоритетні черги, в яких пріоритет елемента залежить від часу його включення в структуру. При вибірці елемента всякий раз вибирається елемент з щонайбільшим пріоритетом.
		</p>

		<p>
			Черги з пріоритетами можуть бути реалізовані на лінійних структурах - в суміжному або зв'язному представленні. Можливі черги з пріоритетним включенням- в яких послідовність елементів черги весь час підтримується впорядкованою,тобто кожний новий елемент включається на те місце в послідовності, яке визначається його пріоритетом, а при виключенні завжди вибирається елемент з голови. Можливі і черги з пріоритетним виключенням - новий елемент включається завжди в кінець черги, а при виключенні в черзі шукається (цей пошук може бути тільки лінійним) елемент з максимальним пріоритетом і після вибірки вилучається з послідовності. І в тому, і в іншому варіанті потрібний пошук, а якщо черга розміщується в статичній пам'яті - ще і переміщення елементів.
		</p>
		<h2>Деки</h2>

		<p>
			Дек - особливий вид черги. Дек (deq - double ended queue, тобто черга з двома кінцями) - це такий послідовний список, в якому як включення, так і виключення елементів, може здійснюватися з будь-якого з двох кінців списку. Так само можна сформулювати поняття деку, як стек, в якому включення і виключення елементів може здійснюватися з обох кінців.
		</p>
		<figure>
			<img class="figc" src="img/03-130.svg">
			<figcaption>Схематичне зображення дека</figcaption>
		</figure>
		<p>
			Деки рідко зустрічаються у своєму первісному визначенні. Окремий випадок деку - дек з обмеженим входом і дек з обмеженим виходом. Логічна і фізична структури деку аналогічні логічній і фізичній структурі кільцевої черги. Проте, стосовно деку доцільно говорити не про голову і хвіст, а про лівий і правий кінець.
		</p>

		<p>
			Над деком доступні наступні операції:
		</p>
		<ol>
			<li>включення елемента праворуч;</li>
			<li>включення елемента ліворуч;</li>
			<li>виключення елемента з права;</li>
			<li>виключення елемента з ліва;</li>
			<li>визначення розміру;</li>
			<li>очищення.</li>
		</ol>

		<p>
			Фізична структура деку в статичній пам'яті ідентична структурі кільцевої черги.
		</p>
		<h2 id="h0" id="h101">Теми для самостійного вивчення</h2>


		<ol>
			<li>Принципи роботи алгоритмів групи CRC</li>
			<li>Принципи роботи алгоритмів групи MD</li>
			<li>Принципи роботи алгоритмів групи SHA</li>
			<li>Недоліки алгоритмів групи MD</li>
		</ol>


		<h2 id="h0" id="h102">Контрольні питання</h2>


		<ol>
			<li>Що таке хеш-функція?</li>
			<li>Яке призначення хеш-функцій?</li>
			<li>Які алгоритми хешування ви знаєте?</li>
			<li>В чому головна відмінність процесів хешування та шифрування?</li>
		</ol>
	</div>
</body>
</html>