<!DOCTYPE html>
<html>
<head>	
	<title> Лекція № 3</title>	
	<meta charset="utf-8">	
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>	
	<div class="paper">		
		<div id="colontitle">Лекція № 3</div>		
		<h1>Статичні структури. Структури та об’єднання</h1>				
		<h2>Структури</h2>

		<p>
			На відміну від масивів чи множин, усі елементи яких однотипні, структура може містити елементи різних типів.		
		</p>
		<figure>
			<img class="figc" src="img/03-010.png">
			<figcaption>Схематичне зображення масиву</figcaption>
		</figure>
		<figure>
			<img class="figc" src="img/03-011.png">
			<figcaption>Схематичне зображення структури (запису)</figcaption>
		</figure>
		

		<p>
			Елементи структури називаються полями структури і можуть мати довільний тип, крім типу цієї ж структури, але можуть бути покажчиками на неї. Якщо при описі структури відсутній тип структури, обов’язково повинен бути вказаний список змінних, покажчиків або масивів визначеної структури.		
		</p>

		<p>
			Звернення до окремих полів структури замінюються на їхні адреси ще на етапі компіляції.		
		</p>

		<p>
			Самою найважливішою операцією для структури є операція доступу до вибраного поля структури - операція кваліфікації.		
		</p>

		<p>
			Над вибраним полем структури можливі будь-які операції, які допустимі для типів цього поля.		
		</p>

		<p>
			Більшість мов програмування підтримує деякі операції, які працюють із структурою, як з єдиним цілим, а не з окремими її полями. Це операція присвоєння значення одного запису іншому однотипному запису, при цьому відбувається по елементне копіювання.		
		</p>
		<h2>Об’єднання</h2>

		<p>
			Об’єднання представляють собою частковий випадок структури, усі поля якої розміщуються за однією ж і тою ж адресою. Формат опису такий же, як і в структури. Довжина об’єднання рівна найбільшій із довжин його полів. У кожен момент часу в змінній типу об’єднання зберігається тільки одне значення, і відповідальність за його правильне використання лягає на програміста.		
		</p>

		<p>
			Об’єднання застосовуються для економії пам’яті в тих випадках, коли відомо, що більше одного поля одночасно не потрібно, а також для різної інтерпретації одного і того ж бітового представлення.		
		</p>

		<p>
			Дуже часто деякі об’єкти програми відносяться до одного й того ж класу, відрізняючись лише деякими деталями. У цьому випадку застосовують комбінацію структурного типу і об’єднання. Об’єднання використовують як поля структури, при цьому в структурі включають поле, яке визначає, який саме елемент об’єднання використовується в кожний момент.		
		</p>

		<p>
			У загальному випадку змінна структура буде складатися з трьох частин: набір спільних компонентів, мітки активного компоненту і частини зі змінними компонентами.		
		</p>
		<h2>Таблиці</h2>

		<p>
			Елементами векторів і масивів можуть бути інтегровані структури. Одна з таких складних структур - таблиця. З фізичної точки зору таблиця є вектором, елементами якого є структури. Характерною логічною особливістю таблиць є те, що доступ до елементів таблиці проводиться не за номером (індексом), а за ключем - значення однієї з властивостей об’єкту, який описується структурою-елементом таблиці. Ключ - це властивість, що ідентифікує дану структуру в множині однотипних структур і є, як правило, унікальним в даній таблиці. Ключ може включатися до складу структури і бути одним з його полів, але може і не включатися в структуру, а обчислюватися за деякими її властивостями. Таблиця може мати один або декілька ключів.		
		</p>

		<p>
			Основною операцією при роботі з таблицями є операція доступу до структури за ключем. Вона реалізовується процедурою пошуку. Оскільки пошук може бути значне більш ефективним в таблицях, впорядкованих за значеннями ключів, досить часто над таблицями необхідно виконувати операції сортування.		
		</p>

		<p>
			Іноді розрізняють таблиці з фіксованою і із змінною довжиною структури. Очевидно, що таблиці, які об’єднують структури ідентичних типів, будуть мати фіксовані довжини структур. Необхідність в змінній довжині може виникнути в задачах, подібних до тих, які розглядалися для об’єднань. Як правило таблиці для таких задач і складаються із структур до складу яких входять об’єднання, тобто зводяться до фіксованої (максимальній) довжини структури. Значно рідше зустрічаються таблиці з дійсно змінною довжиною структури. Хоча в таких таблицях і економиться пам’ять, але можливості роботи з такими таблицями обмежені, оскільки за номером структури неможливо визначити її адресу. Таблиці із структурами змінної довжини обробляються тільки послідовно - в порядку зростання номерів структур. Доступ до елемента такої таблиці звичайно здійснюється в два кроки. На першому кроці вибирається постійна частина структури, в якій міститься, - в явному чи неявному вигляді - довжина структури. На другому кроці вибирається змінна частина структури у відповідності з її довжиною. Додавши до адреси поточної структури її довжину, одержують адресу наступної структури. 		
		</p>
		<h2>Характерні особливості напівстатичних структур</h2>

		<p>
			Напівстатичніструктури даних характеризуються наступними ознаками:
		</p>
		<ol>	
			<li>		вони мають змінну довжину і прості процедури її зміни;	</li>	
			<li>		зміна довжини структури відбувається в певних межах, не перевищуючи якогось максимального (граничного) значення.	</li>
		</ol>

		<p>
			Якщо напівстатичну структуру розглядати на логічному рівні, то цепослідовність даних, зв’язана відносинами лінійного списку. Доступ до елементаможе здійснюватися за його порядковим номером.
		</p>

		<p>
			Фізичне представлення напівстатичних структур даних в пам’яті - цезвичайно послідовність комірок в пам’яті, де кожний наступний елементрозташований в пам’яті в наступній комірці. Фізичне представлення може матитакож вид одно-направленого зв’язного списку (ланцюжки), де кожний наступнийелемент адресується покажчиком, який знаходиться в поточному елементі. У цьомувипадку обмеження на довжину структури менш строгі.
		</p>
		<h2>Стеки</h2>

		<p>
			Стекомназивається множина деякої змінної кількості даних, над якою виконуютьсянаступні операції:
		</p>
		<ol>	
			<li>Поповнення стеку новими даними;</li>	
			<li>Перевірка, яка визначає чи стекпустий;</li>	
			<li>Перегляд останніх добавленихданих;</li>	
			<li>Знищення останніх добавленихданих.</li>
		</ol>

		<p>
			Наоснові такого функціонального опису, можна сформувати логічний опис. Стек - цетакий послідовний список із змінній довжиною, включення і виключення елементівз якого виконуються тільки з одного боку списку. Застосовуються і інші назвистеку - магазин, пам’ять що функціонує за принципом LIFO (Last - In - First -Out - „останнім прийшов - першим вийшов”).
		</p>

		<figure>
			<img class="figc" src="img/03-110.png">
			<figcaption>Схематичне зображення стеку</figcaption>
		</figure>

		<p>
			Самий„верхній” елемент стеку, тобто останній добавлений і ще не знищений, відіграєособливу роль: саме його можна модифікувати й знищувати. Цей елемент називаютьвершиною стеку. Іншу частину стеку називають тілом стеку. Тіло стеку, самособою, є стеком: якщо виключити зі стеку його вершину, то тіло перетворюється встек.
		</p>

		<p>
			Основніоперації над стеком - включення нового елемента (<b>push </b>- заштовхувати) івиключення елемента зі стеку (<b>pop </b>- вискакувати).
		</p>

		<p>
			Кориснимиможуть бути також допоміжні операції:
		</p>
		<ol>	
			<li>визначення поточної кількостіелементів в стеку;</li>	
			<li>очищення стеку;</li>	
			<li>„неруйнуюче” читання елемента звершини стека, яке може бути реалізоване, як комбінація основних операцій -виключити елемент зі стеку та включити його знову в стек.</li>
		</ol>

		<p>
			Припредставленні стеку в статичній пам’яті для стеку виділяється пам’ять, як длявектора. В описі цього вектора окрім звичайних для вектора параметрів повинензнаходитися також покажчик стеку - адреса вершини стека. Обмеження даногопредставлення полягає в тому, що розмір стеку обмежений розмірами вектора.
		</p>

		<p>
			Покажчикстеку може вказувати або на перший вільний елемент стеку, або на останнійзаписаний в стек елемент. Однаково, який з цих двох варіантів вибрати, важливонадалі строго дотримуватися його при обробці стеку.
		</p>

		<p>
			Призанесенні елементу в стек елемент записується на місце, яке визначаєтьсяпокажчиком стеку, потім покажчик модифікується так, щоб він вказував нанаступний вільний елемент (якщо покажчик вказує на останній записаний елемент,то спочатку модифікується покажчик, а потім проводиться запис елемента).Модифікація покажчика полягає в надбавці до нього або у відніманні від ньогоодиниці (стек росте у бік збільшення адреси).
		</p>

		<p>
			Операціявиключення елемента полягає в модифікації покажчика стеку (в напрямку,зворотному модифікації при включенні) і вибірці значення, на яке вказуєпокажчик стеку. Після вибірки комірка, в якій розміщувався вибраний елемент,вважається вільною.
		</p>

		<p>
			Операціяочищення стеку зводиться до запису в покажчик стеку початкового значення -адреси початку виділеної ділянки пам’яті.
		</p>

		<p>
			Визначеннярозміру стека зводиться до обчислення різниці покажчиків: покажчика стеку йадреси початку ділянки.
		</p>

		<p>
			Призв’язному представленні стеку кожен елемент стеку складається із значення іпокажчика, який вказує на попередньо занесений у стек елемент. Зв’язнепредставлення викликає втрату пам’яті, що викликане наявністю покажчика вкожному елементі стеку, і представляє інтерес тільки у випадку, коли важковизначити максимальний розмір стеку.
		</p>

		<p>
			Отже,для зв’язного представлення стеку потрібно, щоб кожен його елемент описувавсяструктурою, яка поєднує дані і покажчик на наступний елемент.
		</p>

		<p>
			Длявиконання операцій над стеком потрібен один покажчик на вершину стеку.Створення пустого стеку полягатиме у присвоєнні покажчику на вершину нульовогозначення, що означатиме, що стек пустий.
		</p>

		<p>
			Послідовністькроків для добавлення елементу в стек складається з декількох кроків:
		</p>
		<ol>	
			<li>Виділити пам’ять під новий елементстеку;</li>	
			<li>Занесення значення в інформаційнеполе;</li>	
			<li>Встановлення зв’язку між ним і„старою” вершиною стеку;</li>	
			<li>Переміщення вершини стеку на новийелемент.</li>
		</ol>

		<p>
			Вилученняелементу зі стеку також проводять за кілька кроків:
		</p>
		<ol>	
			<li>Зчитування інформації зінформаційного поля вершини стеку;</li>	
			<li>Встановлення на вершину стекудопоміжного покажчика;</li>	
			<li>Переміщення покажчика вершинистеку на наступний елемент;</li>	
			<li>Звільнення пам’яті, яку займає„стара” вершина стеку.</li>
		</ol>
		<h2>Черга</h2>

		<p>
			Чергоюназивається множина змінної кількості даних, над якою можна виконувати наступніоперації:
		</p>
		<ol>	
			<li>Поповнення черги новими даними;</li>	
			<li>Перевірка, яка визначає чи пустачерга;</li>	
			<li>Перегляд перших добавлених даних;</li>	
			<li>Знищення самих перших добавленихданих.</li>
		</ol>

		<p>
			Наоснові такого функціонального опису, можна сформувати логічний опис. ЧергоюFIFO (First - In - First - Out - „першим прийшов - першим вийшов”). називаєтьсятакий послідовний список із змінній довжиною, в якому включення елементіввиконується тільки з одного боку списку (хвіст черги), а виключення - з другогобоку (голова черги).
		</p>

		<figure>
			<img class="figc" src="img/03-120.png">
			<figcaption>Схематичне зображення черги</figcaption>
		</figure>

		<p>
			Основніоперації над чергою - ті ж, що і над стеком - включення, виключення, визначеннярозміру, очищення, „неруйнуюче” читання.
		</p>

		<p>
			Припредставленні черги вектором в статичній пам’яті на додаток до звичайних дляопису вектора параметрів в ньому повинні знаходитися два покажчики: на голову іна хвіст черги. При включенні елемента в чергу елемент записується за адресою,яка визначається покажчиком на хвіст, після чого цей покажчик збільшується наодиницю. При виключенні елемента з черги вибирається елемент, що адресуєтьсяпокажчиком на голову, після чого цей покажчик зменшується на одиницю.
		</p>

		<p>
			Очевидно,що з часом покажчик на хвіст при черговому включенні елемента досягне верхньоїмежі тієї ділянки пам’яті, яка виділена для черги. Проте, якщо операціївключення чергувати з операціями виключення елементів, то в початковій частинівідведеної під чергу пам’яті є вільне місце. Для того, щоб місця, займанівиключеними елементами, могли бути повторно використані, черга замикається вкільце: покажчики (на початок і на кінець), досягнувши кінця виділеної областіпам’яті, перемикаються на її початок. Така організація черги в пам’ятіназивається кільцевою чергою. Можливі, звичайно, і інші варіанти організації:наприклад, всякий раз, коли покажчик кінця досягне верхньої межі пам’яті, зсовувативсі не порожні елементи черги до початку ділянки пам’яті, але як цей, так іінші варіанти вимагають переміщення в пам’яті елементів черги і менш ефективні,ніж кільцева черга.
		</p>

		<p>
			Упочатковому стані покажчики на голову і хвіст вказують на початок ділянкипам’яті. Рівність цих двох покажчиків є ознакою порожньої черги. Якщо в процесіроботи з кільцевою чергою кількість операцій включення перевищує кількістьоперацій виключення, то може виникнути ситуація, в якій покажчик кінця„наздожене” покажчик початку. Це ситуація заповненої черги, але якщо в ційситуації покажчики порівняються, ця ситуація буде така ж як при порожній черзі.Для розрізнення цих двох ситуацій до кільцевої черги пред’являється вимога, щобміж покажчиком кінця і покажчиком початку залишався „проміжок” з вільнихелементів. Коли цей „проміжок” скорочується до одного елемента, чергавважається заповненою і подальші спроби запису в неї блокуються. Очищення чергизводиться до запису одного і того ж (не обов’язково початкового) значення вобидва покажчики. Визначення розміру полягає в обчисленні різниці покажчиків зурахуванням кільцевої природи черги.
		</p>

		<p>
			Призв’язному представленні черги кожен елемент черги складається із значення іпокажчика, який вказує на попередньо занесений у чергу елемент.
		</p>

		<p>
			Зв’язнепредставлення викликає втрату пам’яті, що викликане наявністю покажчика вкожному елементі черги, і представляє інтерес тільки у випадку, коли важковизначити максимальний розмір черги. Для зв’язного представлення чергипотрібно, щоб кожен його елемент описувався структурою, яка поєднує дані іпокажчик на наступний елемент.
		</p>

		<p>
			Длявиконання операцій над чергою потрібно два покажчики: на голову і хвіст черги.Створення пустої черги полягатиме у присвоєнні покажчикам на голову і хвістчерги нульових значень, що означатиме, що черга пуста.
		</p>

		<p>
			Послідовністькроків для добавлення елемента в кінець черги складається з декількох кроків:
		</p>
		<ol>	
			<li>Виділити пам’ять під новий елементчерги;</li>	
			<li>Занесення значення в інформаційнеполе;</li>	
			<li>Занесення нульового значення впокажчик;</li>	
			<li>Встановлення зв’язку між ним іостаннім елементом черги і новим, враховуючи випадок пустої черги;</li>
			<li>Переміщення покажчика кінця чергина новий елемент.</li>
		</ol>

		<p>
			Вилученняелементу з черги також проводять за кілька кроків:
		</p>
		<ol>	
			<li>Зчитування інформації з інформаційного поля голови черги;</li>	
			<li>Встановлення на голову черги допоміжного покажчика;</li>	
			<li>Переміщення покажчика початку черги на наступний елемент;</li>	
			<li>Звільнення пам’яті, яку займав перший елемент черги.</li>	
		</ol>

		<p>
			Вреальних задачах іноді виникає необхідність у формуванні черг, відмінних відприведених структур. Порядок вибірки елементів з таких черг визначаєтьсяпріоритетами елементів. Пріоритет в загальному випадку може бути представленийчисловим значенням, яке обчислюється або на підставі значень яких-небудь полівелемента, або на підставі зовнішніх чинників. Так попередньо наведені структуристек і черги можна трактувати як пріоритетні черги, в яких пріоритет елементазалежить від часу його включення в структуру. При вибірці елемента всякий развибирається елемент з щонайбільшим пріоритетом.
		</p>

		<p>
			Черги з пріоритетами можуть бути реалізовані на лінійних структурах - всуміжному або зв’язному представленні. Можливі черги з пріоритетним включенням- в яких послідовність елементів черги весь час підтримується впорядкованою,тобто кожний новий елемент включається на те місце в послідовності, якевизначається його пріоритетом, а при виключенні завжди вибирається елемент зголови. Можливі і черги з пріоритетним виключенням - новий елемент включаєтьсязавжди в кінець черги, а при виключенні в черзі шукається (цей пошук може бутитільки лінійним) елемент з максимальним пріоритетом і після вибірки вилучаєтьсяз послідовності. І в тому, і в іншому варіанті потрібний пошук, а якщо чергарозміщується в статичній пам’яті - ще і переміщення елементів.
		</p>
		<h2>Деки</h2>

		<p>
			Дек - особливий вид черги. Дек (deq - double ended queue, тобто черга з двомакінцями) - це такий послідовний список, в якому як включення, так і виключенняелементів, може здійснюватися з будь-якого з двох кінців списку. Так само можнасформулювати поняття деку, як стек, в якому включення і виключення елементівможе здійснюватися з обох кінців.
		</p>
		<figure>
			<img class="figc" src="img/03-130.svg">
			<figcaption>Схематичне зображення дека</figcaption>
		</figure>
		<p>
			Декирідко зустрічаються у своєму первісному визначенні. Окремий випадок деку - декз обмеженим входом і дек з обмеженим виходом. Логічна і фізична структури декуаналогічні логічній і фізичній структурі кільцевої черги. Проте, стосовно декудоцільно говорити не про голову і хвіст, а про лівий і правий кінець.
		</p>

		<p>
			Наддеком доступні наступні операції:
		</p>
		<ol>	
			<li>включення елемента праворуч;</li>	
			<li>включення елемента ліворуч;</li>	
			<li>виключення елемента з права;</li>	
			<li>виключення елемента з ліва;</li>	
			<li>визначення розміру;</li>	
			<li>очищення.</li>
		</ol>

		<p>
			Фізична структура деку в статичній пам’яті ідентична структурікільцевої черги.
		</p>
	</div>
</body>
</html>