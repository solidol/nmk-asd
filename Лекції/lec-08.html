<!DOCTYPE html> 
<html> 
<head> 
	<title>АСД. Лекція № 8</title> 
	<meta charset="utf-8"> 
	<link rel="stylesheet" type="text/css" href="style.css">  
</head> 
<body> 
	<div class="paper"> 
		<div id="colontitle">АСД. Лекція № 8</div> 
		<ul class="lec-menu">  
			<li><a href="index.html">Зміст</a></li>

			<li><a href="lec-01.html">01</a></li>

			<li><a href="lec-02.html">02</a></li>

			<li><a href="lec-03.html">03</a></li>

			<li><a href="lec-04.html">04</a></li>

			<li><a href="lec-05.html">05</a></li>

			<li><a href="lec-06.html">06</a></li>

			<li><a href="lec-07.html">07</a></li>

			<li><a href="lec-08.html">08</a></li>

			<li><a href="lec-09.html">09</a></li>

			<li><a href="lec-10.html">10</a></li>

		</ul>  
		<h1>Алгоритми сортування</h1> 
		<div class="content-board"> 
			<ol>  
				<li><a href="#h01">Задача сортування</a></li>

				<li><a href="#h02">Сортування вибіркою</a></li>

				<li><a href="#h03">Сортування включенням</a></li>

				<li><a href="#h04">Сортування розподілом</a></li>

				<li><a href="#h05">Сортування злиттям</a></li>

				<li><a href="#h06">Рандомізація</a></li>

				<li><a href="#h07">Підсумок</a></li>

				<li><a href="#h101">Теми для самостійного вивчення</a></li>

				<li><a href="#h102">Контрольні питання</a></li>

			</ol> 
		</div>  
		<h2 id="h01">Задача сортування</h2>  
		<p>
			Для самого загального випадку задачу сортування формулюється: є деяка неврегульована вхідна множина ключів і потрібно отримати множину цих же ключів, впорядкованих за збільшенням або зменшенням. 
		</p>

		<p>
			Зі всіх задач програмування сортування, можливо, має найбагатший вибір алгоритмів розв’язку. Назвемо деякі чинники, які впливають на вибір алгоритму. 
		</p>

		<p>
			1. Наявний ресурс пам’яті: повинні вхідна й вихід множини розташовуватися в різних ділянках пам’яті, чи вихідна множина може бути сформована на місці вхідної. В останньому випадку наявна ділянка пам’яті повинна в ході сортування динамічно перерозподілятися між вхідною і вихідною множинами. 
		</p>

		<p>
			2. Початкова впорядкованість вхідної множини: у вхідній множині можуть попадатися впорядковані ділянки. В граничному випадку вхідна множина може виявитися вже впорядкованою. Одні алгоритми не враховують початкової впорядкованості і вимагають одного і того ж часу для сортування будь-якої множини даного обсягу, інші виконуються тим швидше, чим краще впорядкованість на вході. 
		</p>

		<p>
			3. Часові характеристики операцій: при визначенні порядку алгоритму час виконання вважається звичайно пропорційним кількості порівнянь ключів. Ясно, проте, що порівняння числових ключів виконується швидше, ніж стрічкових, операції пересилки, характерні для деяких алгоритмів, виконуються тим швидше, ніж менший об’єм записів. Залежно від характеристик запису таблиці може бути вибраний алгоритм, що забезпечує мінімізацію числа тих чи інших операцій. 
		</p>

		<p>
			4. Складність алгоритму. Простий алгоритм вимагає меншого часу для його реалізації і вірогідність помилки в реалізації його менше. При програмуванні вимоги дотримання термінів розробки і надійності продукту можуть навіть превалювати над вимогами ефективності функціонування. 
		</p>

		<p>
			Алгоритм сортування називається усталеним, якщо у відсортованому масиві він не змінює порядку розташування елементів. 
		</p>

		<p>
			Ефективність методів сортування визначається двома параметрами: 
		</p>

		<p>
			• кількістю порівнянь; 
		</p>

		<p>
			• кількістю пересилань елементів. 
		</p>

		<p>
			Різноманітність алгоритмів сортування вимагає деякої їхньої класифікації. Вибраний один з вживаних для класифікації підходів, орієнтований перш за все на логічні характеристики використовуваних алгоритмів. Згідно цьому підходу будь- який алгоритм сортування використовує одну з наступних чотирьох стратегій (або їхню комбінацію). 
		</p>

		<p>
			1. Стратегія вибірки. З вхідної множини вибирається наступний за критерієм впорядкованості елемент і включається в вихідну множину на наступне з місце. 
		</p>

		<p>
			2. Стратегія включення. З вхідної множини вибирається наступний за номером елемент і включається в вихідну множину на те місце, яке він повинен займати відповідно до критерію. 
		</p>

		<p>
			3. Стратегія розподілу. Вхідна множина розбивається на ряд підмножин і сортування ведеться у середині кожної такої підмножини. 
		</p>

		<p>
			4. Стратегія злиття. Вихідна множина отримується шляхом злиття маленьких впорядкованих підмножин. 
		</p>
		<h2 id="h02">Сортування вибіркою</h2>  
		<p>
			Даний метод реалізує практично „дослівно” стратегію вибірки. При програмній реалізації алгоритму виникає проблема значення ключа „порожньо”. Досить часто програмісти використовують в якості такого деяке явно відсутнє у вхідній послідовності значення ключа. Інший підхід - створення окремого вектора, кожний елемент якого має логічний тип і відображає стан відповідного елемента вхідної множини. 
		</p>

		<p>
			Алгоритм сортування простою вибіркою рідко застосовується. Набагато частіше застосовується його обмінний варіант. При обмінному сортуванні вибіркою вхідна і вихід множини розташовуються в одній і тій же ділянці пам’яті; вихідна - на початку ділянки, вхідна - в тій частині, що залишилася. У початковому стані вхідна множина займає всю ділянку, а вихідна множина - порожня. У міру виконання сортування вхідна множина звужується, а вихідна - розширяється. 
		</p>

		<p>
			Принцип методу полягає в наступному. Знаходять і вибирають в масиві елементів елемент з мінімальним значенням на інтервалі від першого до останнього елемента і міняють його місцями з першим елементом. На другому кроці знаходять елемент з мінімальним значенням на інтервалі від другого до останнього елемента і міняють місцями його з другим елементом. І так далі для всіх елементів. 
		</p>

		<p>
			Очевидно, що обмінний варіант забезпечує економію пам’яті та при його реалізації не виникає проблема „порожнього” значення. Загальна кількість порівнянь зменшується удвічі - <i class="formula">N*(N-1)/2</i>, але порядок алгоритму залишається степеневим. Кількість перестановок <i class="formula">N-1</i>, але перестановка удвічі більше потребує часу, ніж пересилка в попередньому алгоритмі. 
		</p>

		<p>
			Досить проста модифікація алгоритму обмінного сортування вибіркою передбачає пошук в одному циклі перегляду вхідної множини відразу і мінімуму, і максимуму, і обмін їх з першим і з останнім елементами множини відповідно. Хоча сумарна кількість порівнянь і пересилок в цій модифікації не зменшується, досягається економія на кількості ітерацій зовнішнього циклу. 
		</p>

		<p>
			Приведені вище алгоритми сортування вибіркою практично нечутливі до початкової впорядкованості. В будь-якому випадку пошук мінімуму вимагає повного перегляду вхідної множини. В обмінному варіанті початкова впорядкованість може дати деяку економію на перестановках для випадків, коли мінімальний елемент знайдений на першому місці у вхідній множині. 
		</p>

		<p>
			Ще один варіант такого сортування - сортування бульбашкою. При перегляді вхідної множини попарно порівнюються сусідні елементи множини. Якщо порядок їхнього проходження не відповідає заданому критерію впорядкованості, то елементи міняються місцями. В результаті одного такого перегляду при сортуванні за збільшенням елементів елемент з найбільшим значенням ключа переміститься („спливе”) на останнє місце в множині. При наступному проході на своє місце „спливе” другий за величиною ключа елемент і т.д. Вихідна множина, таким чином, формується в кінці сортованої послідовності, при кожному наступному проході його об’єм збільшується на <i class="formula">1</i>, а об’єм вхідної множини зменшується на <i class="formula">1</i>. 
		</p>

		<p>
			Порядок сортування бульбашкою - <i class="formula">O(N<sup>2</sup>)</i>. Середнє число порівнянь - <i class="formula">N*(N- 1)/2</i> і таке ж середня кількість перестановок, що значно гірше, ніж для обмінного сортування простим вибором. Проте, та обставина, що тут завжди порівнюються і переміщаються тільки сусідні елементи, робить сортування бульбашкою зручним для обробки зв’язних списків. 
		</p>

		<p>
			Ще одна перевага сортування бульбашкою полягає в тому, що при незначних модифікаціях її можна зробити чутливою до початкової впорядкованості вхідної множини. 
		</p>

		<p>
			Ще одна модифікація сортування бульбашкою носить назву шейкер- сортування. Суть її полягає в тому, що напрями переглядів чергують: за проходом до кінця множини слідує прохід від кінця до початку вхідної множини. При перегляді в прямому напрямку запис з найбільшим ключем ставиться на своє місце в послідовності, при перегляді у зворотному напрямі - запис з самим меншим. Цей алгоритм досить ефективний для задач відновлення впорядкованості, коли початкова послідовність вже була впорядкована, але піддалася не дуже значним змінам. Впорядкованість в послідовності з одиночною зміною буде гарантовано відновлена усього за два проходи. 
		</p>

		<p>
			Сортування Шелла - ще одна модифікація сортування бульбашкою. Суть її полягає в тому, що тут виконується порівняння ключів, віддалених один від одного на деяку відстань <i class="formula">d</i>. Початковий розмір <i class="formula">d</i> звичайно вибирається рівним половині загального розміру сортованої послідовності. Виконується сортування бульбашкою з інтервалом порівняння <i class="formula">d</i>. Потім величина <i class="formula">d</i> зменшується удвічі і знов виконується сортування бульбашкою, далі <i class="formula">d</i> зменшується ще удвічі і т.д. Останнє сортування бульбашкою виконується при <i class="formula">d=1</i>. Якісний порядок сортування Шелла залишається <i class="formula">(N<sup>2</sup>)</i>, середнє ж число порівнянь, визначене емпіричним шляхом, - <i class="formula">N*log<sub>2</sub>(N)^2</i>. Прискорення досягається за рахунок того, що виявленні „не на місці” елементи при <i class="formula">d&gt;1</i>, швидше „спливають” на свої місця. 
		</p>
		<h2 id="h03">Сортування включенням</h2>  
		<p>
			Цей метод - „дослівна” реалізації стратегії включення. Порядок алгоритму сортування простим включенням - <i class="formula">O(N<sup>2</sup></i>), якщо враховувати тільки операції порівняння. Але сортування вимагає ще й в середньому <i class="formula">N<sup>2</sup>/4</i> переміщень, що робить її в такому варіанті значне менш ефективною, ніж сортування вибіркою. 
		</p>

		<p>
			Ефективність алгоритму може бути дещо поліпшена при застосуванні не лінійного, а дихотомічного пошуку. Проте, слід мати на увазі, що таке збільшення ефективності може бути досягнуте лише на значній кількості елементів. Так як алгоритм вимагає великої кількості пересилок, при значному обсязі одного запису ефективність може визначатися не кількістю операцій порівняння, а кількістю пересилок. 
		</p>

		<p>
			Реалізація алгоритму обмінного сортування простими вставками відрізняється від базового алгоритму тільки тим, що вхідна і вихідна множина розміщені в одній ділянці пам’яті. 
		</p>

		<p>
			Бульбашкове сортування включенням - це модифікація обмінного варіанту сортування. В цьому методі вхідна і вихід множини знаходяться в одній послідовності, причому вихід - в початковій її частині. В початковому стані можна вважати, що перший елемент послідовності вже належить впорядкованій вихідній множині, інша частина послідовності - невпорядкована. Перший елемент вхідної множини примикає до кінця вихідної множини. На кожному кроці сортування відбувається перерозподіл послідовності: вихідна множина збільшується на один елемент, а вхідна - зменшується. Це відбувається за рахунок того, що перший елемент вхідної множини тепер вважається останнім елементом вихідної. Потім виконується перегляд вихідної множини від кінця до початку з перестановкою сусідніх елементів, які не відповідають критерію впорядкованості. Перегляд припиняється, коли припиняються перестановки. Це приводить до того, що останній елемент вихідної множини „випливає” на своє місце в множині. Оскільки при цьому перестановка приводить до зсуву нового в вихідній множині елемента на одну позицію ліворуч, немає сенсу кожен раз проводити повний обмін між сусідніми елементами - достатньо зсовувати старий елемент праворуч, а новий елемент записати в вихідну множину, коли його місце буде встановлено. 
		</p>

		<p>
			Хоча обмінні алгоритми стратегії включення і дозволяють скоротити число порівнянь за наявності деякої початкової впорядкованості вхідної множини, значна кількість пересилок істотно знижує ефективність цих алгоритмів. Тому алгоритми включення доцільно застосовувати до зв’язних структур даних, коли операція перестановки елементів структури вимагає не пересилки даних в пам’яті, а виконується способом корекції покажчиків. 
		</p>

		<p>
			Турнірний метод сортування отримав свою назву через схожість з кубковою системою проведення спортивних змагань: учасники змагань розбиваються на пари, в яких розігрується перший тур; з переможців першого туру складаються пари для розіграшу другого туру і т.д. Алгоритм сортування складається з двох етапів. На першому етапі будується дерево: аналогічне схемі розіграшу кубка. 
		</p>

		<p>
			Алгоритм сортування впорядкованим бінарним деревом складається з побудови впорядкованого бінарного дерева і подальшого його обходу. Якщо немає необхідності в побудові всього лінійного впорядкованого списку значень, то немає необхідності і в обході дерева, в цьому випадку застосовується пошук у впорядкованому бінарному дереві. Відзначимо, що порядок алгоритму - <i class="formula">O(N*log<sub>2</sub>(N))</i>, але в конкретних випадках все залежить від впорядкованості початкової послідовності, який впливає на ступінь збалансованості дерева і нарешті - на ефективність пошуку. 
		</p>

		<p>
			Заслуговує на увагу модифікація цього алгоритму запропонована Р.Флойдом. Метод сортування за допомогою прямої вибірки базується на повторних пошуках найменшого ключа серед <i class="formula">N</i> елементів, серед тих що залишилися <i class="formula">N-1</i> елементів і так далі. Удосконалити такий метод сортування можна залишаючи після кожного проходу більше інформації, ніж просто ідентифікація єдиного мінімального елемента. Наприклад, виконавши <i class="formula">n/2</i> порівнянь, можна визначити в кожній парі ключів менший. За допомогою <i class="formula">n/4</i> порівнянь - менший із пари вже вибраних менших і так далі. Провівши <i class="formula">n-1</i> порівнянь, можна побудувати дерево вибору і ідентифікувати його корінь як потрібний найменший ключ. 
		</p>

		<p>
			Другий етап сортування - спуск вздовж шляху, відміченого найменшим елементом, і виключення його з дерева шляхом заміни або на пустий елемент (дірку) в самому низу, або на елемент із сусідньої гілки в проміжних вершинах. Елемент, який перемістився в корінь дерева, знову буде найменшим (тепер вже другим) ключем, і його можна виключити. Після <i class="formula">n</i> таких кроків дерево стане пустим і процес сортування завершується. 
		</p>

		<p>
			Звичайно, хотілося б позбавитися дірок, якими в кінцевому рахунку буде заповнене все дерево і які породжують багато непотрібних порівнянь. Крім того, потрібно знайти б таке представлення дерева з <i class="formula">n</i> елементів, яке потребує лише <i class="formula">n</i> одиниць пам’яті. 
		</p>

		<p>
			Р. Флойдом був запропонований деякий „лаконічний” спосіб побудови піраміди „на тому ж місці”, який використовує функцію зсуву елементів початкового вектора. 
		</p>

		<p>
			Сортування частково впорядкованим бінарним деревом також належить до цієї групи сортування. У бінарному дереві, яке будується при цьому для кожного вузла справедливе наступне твердження: значення ключа, записане у вузлі, менше, ніж ключі його нащадків. Для повністю впорядкованого дерева є вимоги до співвідношення між ключами нащадків. Для даного дерева таких вимог немає, тому таке дерево і називається частково впорядкованим. Крім того, таке дерево повинно бути абсолютно збалансованим. Це означає не тільки те, що довжини шляхів до будь-якого двох листків розрізняються не більш, ніж на <i class="formula">1</i>, але і те, що при додаванні нового елемента в дерево перевага завжди віддається лівій гілці, поки це не порушує збалансованість. 
		</p>

		<p>
			Для сортування цим методом потрібно визначити дві операції: вставка в дерево нового елемента і вибірка з дерева мінімального елемента; причому виконання будь-якій з цих операцій не повинне порушувати ні сформульованої вище часткової впорядкованості дерева, ні його збалансованості. 
		</p>

		<p>
			Якщо застосовувати сортування частково впорядкованим деревом для впорядкування вже готової послідовності розміром <i class="formula">N</i>, то необхідно <i class="formula">N</i> раз виконати вставку, а потім <i class="formula">N</i> раз - вибірку. Порядок алгоритму - <i class="formula">O(N*log<sub>2</sub>(N))</i>, але середнє значення кількості порівнянь приблизно в 3 рази більше, ніж для турнірного сортування. Але сортування частково впорядкованим деревом має одну істотну перевагу перед всіма іншими алгоритмами - це найзручніший алгоритм для „сортування on-line”, коли сортована послідовність не зафіксована до початку сортування, а міняється в процесі роботи і вставки чергують з вибірками. Кожна зміна (додавання елемента) сортованої послідовності вимагає тут не більш, ніж <i class="formula">2*log<sub>2</sub>(N)</i> порівнянь і перестановок, в той час, як інші алгоритми вимагають при одиничній зміні нового впорядковування всієї послідовності „за повною програмою”. 
		</p>
		<h2 id="h04">Сортування розподілом</h2>  
		<p>
			Алгоритм порозрядного сортування вимагає представлення ключів сортованої послідовності у вигляді чисел в деякій системі числення <i class="formula">P</i>. Число проходів сортування рівно максимальному числу значущих цифр в числі - <i class="formula">D</i>. При кожному проході аналізується значуща цифра в черговому розряді ключа, починаючи з молодшого розряду. Всі ключі з однаковим значенням цієї цифри об’єднуються в одну групу. Ключі в групі розташовуються в порядку їхнього надходження. Після того, як вся початкова послідовність розподілена по групах, групи розташовуються в порядку зростання пов’язаних з групами цифр. Процес повторюється для другої цифри і т.д., поки не будуть вичерпані значущі цифри в ключі. Основа системи числення <i class="formula">P</i> може бути будь-якою при цьому потрібно <i class="formula">P</i> груп. 
		</p>

		<p>
			Порядок алгоритму якісно лінійний - <i class="formula">O(N)</i>, для сортування потрібно <i class="formula">D*N</i>операцій аналізу цифри. Проте, в такій оцінці порядку не враховується ряд обставин. 
		</p>

		<p>
			По-перше, операція виділення значущої цифри буде простою і швидкою тільки при <i class="formula">P=2</i>, для інших систем числення ця операція може вимагати значно більше часу, ніж операція порівняння. 
		</p>

		<p>
			По-друге, при оцінці алгоритму не враховуються затрати часу і пам’яті на створення і ведення груп. Розміщення груп в статичній робочій пам’яті вимагає пам’яті для <i class="formula">P*N</i> елементів, оскільки в граничному випадку всі елементи можуть потрапити в якусь одну групу. Якщо ж формувати групи усередині тієї ж послідовності за принципом обмінних алгоритмів, то виникає необхідність перерозподілу послідовності між групами і всі проблеми і недоліки, властиві алгоритмам включення. Найбільш раціональним є формування груп у вигляді зв’язних списків з динамічним виділенням пам’яті. 
		</p>

		<p>
			Алгоритм швидкого сортування Хоара відноситься до розподільних і забезпечує показники ефективності <i class="formula">O(N*log<sub>2</sub>(N))</i> навіть при якнайгіршому початковому розподілі. 
		</p>

		<p>
			Використовується два індекси з початковими значеннями початку і кінця множини відповідно. Ключ початку порівнюється з ключем кінця. Якщо ключі задовольняють критерію впорядкованості, то індекс кінця зменшується на <i class="formula">1</i> і проводиться наступне порівняння. Якщо ключі не задовольняють критерію, то записи міняються місцями. При цьому індекс кінця фіксується і починає мінятися індекс початку (збільшуватися на <i class="formula">1</i> після кожного порівняння). Після наступної перестановки фіксується початок і починає змінюватися кінець і т.д. Прохід закінчується, коли індекси стають рівними. Запис, що знаходиться на позиції зустрічі індексів, стоїть на своєму місці в послідовності. Цей запис ділить послідовність на дві підмножини. Всі записи, розташовані ліворуч від неї мають ключі, менші ніж ключ цього запису, всі записи праворуч - більші. Той же самий алгоритм застосовується до лівої підмножини, а потім до правої. Записи підмножини розподіляються на дві менші підмножини і так далі. Розподіл закінчується, коли отримана підмножина буде складатися з єдиного елемента - така підмножина вже є впорядкованою. 
		</p>
		<h2 id="h05">Сортування злиттям</h2>  
		<p>
			Алгоритми сортування злиттям, як правило, мають порядок <i class="formula">O(N*log<sub>2</sub>(N))</i>, але відрізняються від інших алгоритмів більшою складністю і вимагають великої кількості пересилок. Алгоритми злиття застосовуються в основному, як складова частина зовнішнього сортування. 
		</p>

		<p>
			При сортуванні попарним злиттям вхідна множина розглядається, як послідовність підмножин, кожна з яких складається з єдиного елемента і, отже, є вже впорядкованим. На першому проході кожні дві сусідні одноелементних множини зливаються в одну двоелементну впорядковану множину. На другому проході двоелементні множини зливаються в 4-елементні впорядковані множини і т.д. Врешті-решт отримують одну велику впорядковану множину. 
		</p>

		<p>
			Самою найважливішою частиною алгоритму є злиття двох впорядкованих множин. Цю частину алгоритму опишемо більш детально. 
		</p>

		<p>
			1. <b>Початкові установки</b>. Визначити довжини першої і другої початкових множин - <i class="formula">l1</i> і <i class="formula">l2</i> відповідно. Встановити індекси поточних елементів в початковій множині <i class="formula">і1</i> і <i class="formula">і2</i> в 0. Встановити індекс в вихідній множині <i class="formula">j=1</i>. 
		</p>

		<p>
			2. <b>Цикл злиття</b>. Виконувати крок 3 до тих пір, поки <i class="formula">і1&lt;=11</i> і <i class="formula">і2&lt;=12</i>. 
		</p>

		<p>
			3. <b>Порівняння</b>. Порівняти ключ <i class="formula">і1</i>-го елемента з першої початкової множини з ключем <i class="formula">і2</i>-го елемента з другої початкової множини. Якщо ключ елемента з 1 -ої множини менший, то записати <i class="formula">і1</i>-тий елемент з 1-ої множини на <i class="formula">j</i>-те місце в вихідній множині і збільшити <i class="formula">і1</i> на 1. Інакше - записати <i class="formula">і2</i>-тий елемент з 2-ої множини на <i class="formula">j</i>-те місце в вихідній множині і збільшити <i class="formula">і2</i> на 1. Збільшити <i class="formula">j</i> на 1. 
		</p>

		<p>
			4. <b>Виведення залишків</b>. Якщо <i class="formula">і1&lt;=11</i>, то переписати частину 1-ої початкової множини від <i class="formula">і1</i> до <i class="formula">l1</i> включно в вихідну множину. Інакше - переписати частину 2-ої початкової множини від <i class="formula">і2</i> до <i class="formula">l2</i> включно в вихідну множину. 
		</p>
		<h2 id="h06">Рандомізація</h2>  
		<p>
			В деяких програмах потрібно виконання операцій, протилежних сортуванню. Отримавши множину елементів, програма повинна розмістити їх у випадковому порядку. Рандомізацію нескладно виконати, використовуючи алгоритм, подібний на сортування вибіркою. 
		</p>

		<p>
			Для кожного розміщення в множині, алгоритм випадковим чином вибирає елемент, який повинен його зайняти з тих, які ще не були розміщені на своєму місці. Потім цей елемент міняється місцями з елементом, який, знаходиться на цій позиції. Так як алгоритм заповнює кожну позицію лише один раз, його складність - <i class="formula">O(N)</i>. 
		</p>

		<p>
			Нескладно показати, що імовірність того, що елемент виявиться на якій- небудь позиції, рівна <i class="formula">1/N</i>. Оскільки елемент може виявитися на будь-якій позиції з однаковою імовірністю, цей алгоритм дійсно приводить до випадкового розміщення елементів. 
		</p>

		<p>
			Результат рандомізації залежить від того, наскільки ефективним є генератор випадкових чисел. Для даного алгоритми не важливий початковий порядок розміщення елементів. Якщо необхідно неодноразово рандомізувати множину елементів, немає необхідності її попередньо сортувати. 
		</p>
		<h2 id="h07">Підсумок</h2>  
		<table> 
			<caption>Зведена таблиця складності алгоритмів сортування</caption> 
			<tr> <td width=165> 
				<p>
					<b>Алгоритм</b>
				</p>
			</td> <td width=108> 
				<p>
					<b>Структура даних</b>
				</p>
			</td> <td width=416 colspan="3"> 
				<p>
					<b>Часова складність</b>
				</p>
			</td> <td width=139> 
				<p>
					<b>Допоміжні дані</b>
				</p>
			</td> </tr> <tr> <td width=165> 
				<p>
					&nbsp;
				</p>
			</td> <td width=108> 
				<p>
					&nbsp;
				</p>
			</td> <td width=139> <p align=center><b>Краща</b>
			</p>
		</td> <td width=139> <p align=center><b>Середня</b>
		</p>
	</td> <td width=139> <p align=center><b>Гірша</b>
	</p>
</td> <td width=139> <p align=center><b>Гірший випадок</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Швидке сортування
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>О(п)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Сортування злиттям
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>О(п)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Пірамідальне сортування
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(n log(n))</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(1)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Бульбашкове сортування
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>О(п)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(1)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Сортування вставкою
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>О(п)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(1)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Сортування вибором
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(1)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Блочне сортування
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(п+к)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>0(п+к)</b>
</p>
</td> <td width=139 nowrap style="background:#F4B084;"> <p align=center><b>0(п<sup>л</sup>2)</b>
</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>О(пк)</b>
</p>
</td> </tr> <tr> <td width=165> 
	<p>
		Порозрядне сортування
	</p>
</td> <td width=108> 
	<p>
		Масив
	</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>O(nk)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>O(nk)</b>
</p>
</td> <td width=139 nowrap style="background:#92D050;"> <p align=center><b>O(nk)</b>
</p>
</td> <td width=139 nowrap style="background:yellow;"> <p align=center><b>0(п+к)</b>
</p>
</td> 
</tr> 
</table>       
<h2 id="h0" id="h101">Теми для самостійного вивчення</h2>   
<ol> 
	<li>Принципи роботи алгоритмів групи CRC</li>
	<li>Принципи роботи алгоритмів групи MD</li>
	<li>Принципи роботи алгоритмів групи SHA</li>
	<li>Недоліки алгоритмів групи MD</li>
</ol>   
<h2 id="h0" id="h102">Контрольні питання</h2>   
<ol> 
	<li>Що таке хеш-функція?</li>
	<li>Яке призначення хеш-функцій?</li>
	<li>Які алгоритми хешування ви знаєте?</li>
	<li>В чому головна відмінність процесів хешування та шифрування?</li>
</ol>  
</div> 
</body> 
</html>