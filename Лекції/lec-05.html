<!DOCTYPE html>
<html>
<head>	
	<title> Лекція № 5</title>	
	<meta charset="utf-8">	
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>	
	<div class="paper">		
		<div id="colontitle">Лекція № 5</div>
		<ul class="lec-menu"> 
			<li><a href="index.html">Зміст</a></li> 
			<li><a href="lec-01.html">01</a></li> 
			<li><a href="lec-02.html">02</a></li> 
			<li><a href="lec-03.html">03</a></li> 
			<li><a href="lec-04.html">04</a></li> 
			<li><a href="lec-05.html">05</a></li> 
			<li><a href="lec-06.html">06</a></li> 
			<li><a href="lec-07.html">07</a></li> 
			<li><a href="lec-08.html">08</a></li> 
			<li><a href="lec-09.html">09</a></li> 
			<li><a href="lec-10.html">10</a></li>  
		</ul> 
		<h1>Динамічні структури даних. Дерева та графи</h1>
		<h2>Зв'язне представлення даних в пам'яті</h2>
		<p>
			Динамічні структури за визначенням характеризуються відсутністюфізичної суміжності елементів структури в пам’яті, непостійністю і непередбачуваністюрозміру (кількість елементів) структури в процесі її обробки.
		</p>

		<p>
			Оскількиелементи динамічної структури розташовуються за не передбачуваними адресамипам’яті, адресу елемента такої структури не можна обчислити за адресоюпочаткового або попереднього елемента. Для встановлення зв’язку між елементамидинамічної структури використовуються покажчики, через які встановлюються явнізв’язки між елементами. Таке представлення даних в пам’яті називаєтьсязв’язним. Елемент динамічної структури складається з двох полів:
		</p>
		<ul>	
			<li>інформаційного поля або поляданих, в якому містяться ті дані, заради яких і створюється структура;</li>	
			<li>поле зв’язку, в якому міститьсяодин або декілька покажчиків, які зв’язують даний елемент з іншими елементамиструктури.</li>
		</ul>

		<p>
			Колизв’язне представлення даних використовується для вирішення прикладної задачі,для кінцевого користувача „видимим” робиться тільки вміст інформаційного поля,а поле зв’язку використовується тільки програмістом- розробником.
		</p>

		<p>
			Перевагизв’язного представлення даних:
		</p>
		<ul>	
			<li>можливість забезпечення значноїзмінності структур;</li>	
			<li>розмір структури обмежуєтьсятільки доступним об’ємом машинної пам’яті;</li>	
			<li>при зміні логічної послідовностіелементів структури потрібно виконати не переміщення даних в пам’яті, а тількикорекцію покажчиків.</li>
		</ul>

		<p>
			Разом зтим зв’язне представлення не позбавлене й недоліків, основні з яких:
		</p>
		<ul>	
			<li>робота з покажчиками вимагає більшвисокої кваліфікації від програміста;</li>	
			<li>на поля зв’язку витрачаєтьсядодаткова пам’ять;</li>	
			<li>доступ до елементів зв’язноїструктури може бути менш ефективним за часом.</li>
		</ul>

		<p>
			Останній недолік є найбільш серйозним і саме ним обмежуєтьсязастосування зв’язного представлення даних. Якщо в суміжному представленніданих для обчислення адреси будь-якого елемента у всіх випадках достатньономера елемента і інформації, яка міститься в описі структури, то для зв’язногопредставлення адреса елемента не може бути обчислена з початкових даних. Описзв’язної структури містить один або декілька покажчиків, які дозволяють увійтидо структури, далі пошук необхідного елемента виконується проходженнямланцюжком покажчиків від елемента до елемента. Тому зв’язне представленняпрактично ніколи не застосовується в задачах, де логічна структура даних маєвигляд вектора або масиву - з доступом за номером елемента, але частозастосовується в задачах, де логічна структура вимагає іншої початковоїінформації доступу (таблиці, списки, дерева і т.д.).
		</p>
		<h2>Графи</h2>
		<p>
			Граф -це складна нелінійна багато-зв’язна динамічна структура, що відображаєвластивості і зв’язки складного об’єкту.
		</p>

		<p>
			Цябагато-зв’язна структура має наступні властивості:
		</p>
		<ul>	
			<li>на кожний елемент (вузол, вершину)може бути довільна кількість посилань;</li>	
			<li>кожний елемент може мати зв’язок збудь-якою кількістю інших елементів;</li>	
			<li>кожний зв’язок (ребро, дуга) можемати напрям і вагу.</li>
		</ul>

		<p>
			Увузлах графа міститься інформація про елементи об’єкту. Зв’язки між вузламизадаються ребрами графа. Ребра графа можуть мати спрямованість, тоді вониназиваються орієнтованими, в іншому випадку - неорієнтовані. Граф, усі зв’язкиякого орієнтовані, називається орієнтованим графом; граф зі всіманеорієнтованими зв’язками - неорієнтованим графом; граф із зв’язками обох типів- змішаним графом.
		</p>

		<p>
			Існуєдва основні методи представлення графів в пам’яті комп’ютера: матричний ізв’язними нелінійними списками. Вибір методу представлення залежить від природиданих і операцій, що виконуються над ними. Якщо задача вимагає великоїкількості включень і виключень вузлів, то доцільно представляти граф зв’язнимисписками; інакше можна застосувати і матричне представлення.
		</p>

		<p>
			Привикористанні матриць суміжності їхні елементи представляються в пам’ятікомп’ютера елементами масиву. При цьому, для простого графа матриця складаєтьсяз нулів і одиниць, для мультиграфа - з нулів і цілих чисел, які вказуютькратність відповідних ребер, для зваженого графа - з нулів і дійсних чисел, якізадають вагу кожного ребра.
		</p>

		<p>
			Орієнтованийграф представляється зв’язним нелінійним списком, якщо він часто змінюється абоякщо півміри входу і виходу його вузлів великі.
		</p>

		<p>
			Багато-зв’язна структура - граф - знаходить широке застосування приорганізації банків даних, управлінні базами даних, в системах програмногоімітаційного моделювання складних комплексів, в системах штучного інтелекту, взадачах планування і в інших сферах.
		</p>
		<h2>Дерева</h2>
		<p>
			Дерево- це граф, який характеризується наступними властивостями:
		</p>
		<ul>	
			<li>Існує єдиний елемент (вузол абовершина), на який не посилається ніякий інший елемент, - він називаєтьсякоренем.</li>	
			<li>Починаючи з кореня і слідуючи попевному ланцюжку покажчиків, що містяться в елементах, можна здійснити доступдо будь-якого елемента структури.</li>	
			<li>На кожний елемент, крім кореня, єєдине посилання, тобто кожний елемент адресується єдиним покажчиком.</li>
		</ul>

		<p>
			Назва„дерево” виникла з логічної еквівалентності дерево-видної структуриабстрактному дереву з теорії графів. Лінія зв’язку між парою вузлів дереваназивається гілкою. Ті вузли, які не посилаються ні на які інші вузли дерева,називаються листям. Вузол, що не є листком або коренем, вважається проміжнимабо вузлом галуження.
		</p>

		<p>
			В багатьох застосування відносний порядок проходження вершин на кожномуокремому ярусі має певне значення. При представленні дерева в пам’ятікомп’ютера такий порядок вводиться автоматично, навіть якщо він сам по собідовільний. Порядок проходження вершин на деякому ярусі можна легко ввести,позначаючи одну вершину як першу, іншу - як другу і т.д. Замістьвпорядковування вершин можна задавати порядок на ребрах. Якщо в орієнтованомудереві на кожному ярусі заданий порядок проходження вершин, то таке деревоназивається впорядкованим деревом.
		</p>
		<img src="img/image025.jpg" v:shapes="Shape_x0020_37" width="101" hspace="11" height="51" align="right">
		<p>
			Введемо ще деякі поняття, пов’язані з деревами. Вузол X називаєтьсяпредком, або батьком, а вузли Y і Z називаються нащадками, або синами, їх,відповідно, між собою називають братами. Причому, лівий син є старшим сином, аправий - молодшим. Кількість піддерев даної вершини називається мірою цієївершини.
		</p>

		<p>
			Якщо здерева прибрати коріння і ребра, що сполучають коріння з вершинами першогоярусу, то вийде деяка множина незв’язаних дерев. Множина незв’язаних деревназивається лісом.
		</p>

		<p>
			Є рядспособів графічного зображення дерев. Перший спосіб полягає у використовуваннідля зображення піддерев відомого методу діаграм Венна, другий - методу дужок,що вкладаються одна в одну, третій спосіб - це спосіб, який використовуєтьсяпри складанні змісту книг. Останній спосіб, що базується на форматі знумерацією рівнів, схожий з методами, які використовуються в мовахпрограмування. При застосуванні цього формату кожній вершині приписуєтьсячисловий номер, який повинен бути менший номерів, приписаних кореневим вершинамприєднаних до неї піддерев.
		</p>

		<p>
			Повнедерево містить максимально можливу кількість вузлів на кожному рівні, крімнижнього. Повні дерева мають ряд важливих властивостей.
		</p>

		<p>
			По-перше,це найкоротші дерева, які можуть містити задану кількість вузлів. Доситькорисна властивість повних дерев полягає в тому, що вони можуть бути дужекомпактно записані в масивах. Якщо пронумерувати вузли в „природному” порядку,зверху вниз і зліва направо, то можна помістити елементи дерева в масив у цьомуж порядку.
		</p>

		<p>
			Існують<i>m-арні</i> дерева, тобто такі дерева, в яких півміра виходу кожної вершинименша або рівна <i>т.</i> Якщо півміра виходу кожної вершини в точності рівнаабо <i>т,</i> або нулю, то таке дерево називається повним m-арним деревом. При <i>т=2</i>такі дерева називаються відповідно бінарними, або повними бінарними.
		</p>

		<p>
			Представити<i>m</i>-арне дерево в пам’яті комп’ютера складно, так як кожен елемент дереваповинен містити стільки покажчиків, скільки ребер, виходить з вузла. Це приведедо підвищеної витрати пам’яті, різноманітності початкових елементів іускладнить алгоритми обробки дерева. Тому <i>m</i>-арні дерева, ліс необхіднопривести до бінарних для економії пам’яті і спрощенню алгоритмів. Усі вузлибінарного дерева представляються в пам’яті однотипними елементами з двомапокажчиками, крім того, операції над бінарними деревами виконуються просто іефективно.
		</p>

		<p>
			Правилопобудови бінарного дерева з будь-якого дерева:
		</p>
		<ul>	
			<li>В кожному вузлі залишити тількигілку до старшого сина;</li>
			<li>З’єднати горизонтальними ребрамивсіх братів одного батька;</li>
		</ul>

		<p>
			Таким чином перебудувати дерево заправилом:
		</p>
		<ul>
			<li>лівийсин - вершина, розташована під даною;</li>
			<li>правийсин - вершина, розташована праворуч від даної (тобто на одному ярусі з нею).</li>
			<li>Розвернути дерево так, щоб усівертикальні гілки відображали лівих синів, а горизонтальні - правих.</li>
		</ul>

		<p>
			Урезультаті перетворення будь-якого дерева, в бінарне, виходить дерево у вигляділівого піддерева, підвішеного до кореня.
		</p>

		<p>
			Упроцесі перетворення правий покажчик кожного вузла бінарного дерева будевказувати на сусіда по рівню. Якщо такого немає, то правий покажчик - <b>NULL</b>.Лівий покажчик буде вказувати на вершину наступного рівня. Якщо такої немає, топокажчик встановлюється на <b>NULL</b>.
		</p>

		<p>
			Описанийвище метод представлення довільних впорядкованих дерев за допомогою бінарнихдерев можна узагальнити на представлення довільного впорядкованого лісу.
		</p>

		<p>
			Правилопобудови бінарного дерева з лісу: корені всіх піддерев лісу з’єднатигоризонтальними зв’язками. В отриманому дереві вузли в даному прикладі будутьрозташовуватися на трьох рівнях. Далі перебудовувати по раніше розглянутому плану.В результаті перетворення впорядкованого лісу в бінарне дерево виходить повнебінарне дерево з лівим і правим піддеревом.
		</p>

		<p>
			Дереваможна представляти за допомогою зв’язних списків і масивів (або послідовнихсписків).
		</p>

		<p>
			Частішевсього використовується зв’язне представлення дерев, так як воно дуже сильнонагадує логічне. Зв’язне зберігання полягає в тому, що задається зв’язок відбатька до синів. В бінарному дереві є два покажчики, тому зручно вузолпредставити у вигляді структури в якій <i>left</i> - покажчик на лівепіддерево, <i>right</i> - покажчик на праве піддерево, <i>inf -</i> міститьінформацію, яка зв’язана з вершиною і має наперед визначений тип - <i>data.</i>
		</p>

		<p>
			Наддеревами визначені наступні основні операції:
		</p>
		<ul>	
			<li>Пошук вузла із заданим ключем.</li>	
			<li>Додавання нового вузла.</li>	
			<li>Видалення вузла (піддерева).</li>	
			<li>Обхід дерева в певному порядку:
				<ul>
					<li>Низхіднийобхід;</li>
					<li>Змішанийобхід;</li>
					<li>Висхіднийобхід.</li>
				</ul>
			</li>	

		</ul>

		<p>
			Потрібнавершина в дереві шукається за ключем. Пошук в бінарному дереві здійснюєтьсятаким чином.
		</p>

		<p>
			Нехайпобудовано деяке дерево і вимагається знайти вузол з ключем X. Спочаткупорівнюємо з X ключ, що знаходиться в корені дерева. У разі рівності пошукзакінчений і потрібно повернути покажчик на корінь в якості результату пошуку.Інакше переходимо до розгляду вершини, яка знаходиться зліва внизу, якщо ключ Xменший тільки що розглянутого, або справа внизу, якщо ключ X більший тільки щорозглянутого. Порівнюємо ключ X з ключем, що міститься в цій вершині, і т.д.Процес завершується в одному з двох випадків:
		</p>
		<ol>	
			<li>знайдена вершина, що містить ключ,рівний ключу X;</li>	
			<li>в дереві відсутня вершина, до якоїпотрібно перейти для виконання чергового кроку пошуку.</li>
		</ol>

		<p>
			Впершому випадку повертається покажчик на знайдену вершину. В другому - покажчикна вузол, де зупинився пошук (що зручне для побудови дерева ).
		</p>

		<p>
			Длявключення запису в дерево перш за все потрібно знайти в дереві ту вершину, доякої можна приєднати нову вершину, відповідну запису, що включається. При цьомувпорядкованість ключів повинна зберігатися.
		</p>

		<p>
			Алгоритмпошуку потрібної вершини, взагалі кажучи, той же самий, що і при пошуку вершиниіз заданим ключем. Ця вершина буде знайдена в той момент, коли в якостічергового покажчика, який визначає гілку дерева, в якій треба продовжити пошук,виявиться покажчик <b>NULL</b>.
		</p>

		<p>
			Вбагатьох задачах, пов’язаних з деревами, вимагається здійснити систематичнийперегляд всіх його вузлів в певному порядку. Такий перегляд називаєтьсяпроходженням або обходом дерева.
		</p>

		<p>
			Бінарнедерево можна обходити трьома основними способами: низхідним, змішаним івисхідним (можливі також зворотний низхідний, зворотний змішаний і зворотнийвисхідний обходи). Прийняті назви методів обходу зв’язані з часом обробкикореневої вершини: До того як оброблено обидва його піддерева, після того, якоброблено ліве піддерево, але до того як оброблено праве, після того, якоброблено обидва піддерева. Використовувані назви методів відображають напрямобходу в дереві: від кореневої вершини вниз до листя - низхідний обхід; відлистя вгору до кореня - висхідний обхід, і змішаний обхід - від найлівішоголистка дерева через корінь до найправішого листка.
		</p>

		<p>
			Схемноалгоритм обходу бінарного дерева відповідно до низхідного способу можевиглядати таким чином:
		</p>
		<ol>	
			<li>В якості чергової вершини взятикорінь дерева. Перейти до пункту 2.</li>	
			<li>Провести обробку чергової вершинивідповідно до вимог задачі. Перейти до пункту 3.</li>	
			<li>		
				<ol>			
					<li>Якщо чергова вершина має обидвігілки, то в якості нової вершини вибрати ту вершину, на яку посилається лівагілка, а вершину, на яку посилається права гілка, занести в стек; перейти допункту 2;</li>
					<li>якщо чергова вершина є кінцевою, то вибрати в якості нової чергової вершинивершину із стека, якщо він не порожній, і перейти до пункту 2; якщо ж стекпорожній, то це означає, що обхід всього дерева закінчений, перейти до пункту 4;</li>
					<li>якщо чергова вершина має тількиодну гілку, то в якості чергової вершини вибрати ту вершину, на яку ця гілкавказує, перейти до пункту 2.</li>		
				</ol>
			</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Алгоритмістотно спрощується при використовуванні рекурсії. Так, низхідний обхід можнаописати таким чином:
		</p>
		<ol>	
			<li>Обробка кореневої вершини;</li>	
			<li>Низхідний обхід лівого піддерева;</li>	
			<li>Низхідний обхід правогопіддерева.</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Змішанийобхід можна описати таким чином:
		</p>
		<ol>	
			<li>Спуститися по лівій гілці іззапам’ятовуванням вершин в стеку;</li>	
			<li>Якщо стек порожній те перейти доп.5;</li>	
			<li>Вибрати вершину із стеку іобробити дані вершини;</li>	
			<li>Якщо вершина має правого сина, топерейти до нього; перейти до п.1.</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Рекурсивнийзмішаний обхід описується таким чином:
		</p>
		<ol>	
			<li>Змішаний обхід лівого піддерева;</li>	
			<li>Обробка кореневої вершини;</li>	
			<li>Змішаний обхід правого піддерева.</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Складністьреалізації висхідного обходу полягає в тому, що на відміну від попередньогометоду в цьому алгоритмі кожна вершина запам’ятовується в стеку двічі: вперше -коли обходиться ліве піддерево, і другий раз - коли обходиться праве піддерево.Таким чином, в алгоритмі необхідно розрізняти два види стекових записів: 1-йозначає, що в даний момент обходиться ліве піддерево; 2-й - що обходитьсяправе, тому в стеку запам’ятовується покажчик на вузол і ознаку (код-1 і код-2відповідно).
		</p>

		<p>
			Алгоритмвисхідного обходу можна представити таким чином:
		</p>
		<ol>	
			<li>Спуститися по лівій гілці іззапам’ятовуванням вершини в стеку як 1-й вид стекових записів;</li>	
			<li>Якщо стек порожній, то перейти доп.5;</li>	
			<li>Вибрати вершину із стека, якщо цеперший вид стекових записів, то повернути його в стек як 2-й вид стековихзаписів; перейти до правого сина; перейти до п.1, інакше перейти до п.4;</li>	
			<li>Обробити дані вершини і перейти доп.2;</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Рекурсивнийзмішаний обхід описується таким чином:
		</p>
		<ol>	
			<li>Висхідний обхід лівогопіддерева;</li>	
			<li>Висхідний обхід правогопіддерева;</li>	
			<li>Обробка кореневої вершини.</li>	
			<li>Кінець алгоритму.</li>
		</ol>

		<p>
			Якщо в розглянутих вище алгоритмах поміняти місцями поля покажчики налівого і правого сина, то отримують процедури зворотного низхідного, зворотногозмішаного і зворотного висхідного обходів.
		</p>
	</div>
</body>
</html>